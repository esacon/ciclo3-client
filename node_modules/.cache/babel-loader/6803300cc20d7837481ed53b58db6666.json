{"ast":null,"code":"\"use strict\"; // Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _objectSpread = require(\"C:/Users/Enrique Niebles/Documents/Misi\\xF3n TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"C:/Users/Enrique Niebles/Documents/Misi\\xF3n TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Enrique Niebles/Documents/Misi\\xF3n TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JWTAccess = void 0;\n\nvar jws = require(\"jws\");\n\nvar LRU = require(\"lru-cache\");\n\nvar DEFAULT_HEADER = {\n  alg: 'RS256',\n  typ: 'JWT'\n};\n\nvar JWTAccess = /*#__PURE__*/function () {\n  /**\r\n   * JWTAccess service account credentials.\r\n   *\r\n   * Create a new access token by using the credential to create a new JWT token\r\n   * that's recognized as the access token.\r\n   *\r\n   * @param email the service account email address.\r\n   * @param key the private key that will be used to sign the token.\r\n   * @param keyId the ID of the private key used to sign the token.\r\n   */\n  function JWTAccess(email, key, keyId, eagerRefreshThresholdMillis) {\n    _classCallCheck(this, JWTAccess);\n\n    this.cache = new LRU({\n      max: 500,\n      maxAge: 60 * 60 * 1000\n    });\n    this.email = email;\n    this.key = key;\n    this.keyId = keyId;\n    this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;\n  }\n  /**\r\n   * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url\r\n   *\r\n   * @param url The URI being authorized.\r\n   * @param scopes The scope or scopes being authorized\r\n   * @returns A string that returns the cached key.\r\n   */\n\n\n  _createClass(JWTAccess, [{\n    key: \"getCachedKey\",\n    value: function getCachedKey(url, scopes) {\n      var cacheKey = url;\n\n      if (scopes && Array.isArray(scopes) && scopes.length) {\n        cacheKey = url ? \"\".concat(url, \"_\").concat(scopes.join('_')) : \"\".concat(scopes.join('_'));\n      } else if (typeof scopes === 'string') {\n        cacheKey = url ? \"\".concat(url, \"_\").concat(scopes) : scopes;\n      }\n\n      if (!cacheKey) {\n        throw Error('Scopes or url must be provided');\n      }\n\n      return cacheKey;\n    }\n    /**\r\n     * Get a non-expired access token, after refreshing if necessary.\r\n     *\r\n     * @param url The URI being authorized.\r\n     * @param additionalClaims An object with a set of additional claims to\r\n     * include in the payload.\r\n     * @returns An object that includes the authorization header.\r\n     */\n\n  }, {\n    key: \"getRequestHeaders\",\n    value: function getRequestHeaders(url, additionalClaims, scopes) {\n      // Return cached authorization headers, unless we are within\n      // eagerRefreshThresholdMillis ms of them expiring:\n      var key = this.getCachedKey(url, scopes);\n      var cachedToken = this.cache.get(key);\n      var now = Date.now();\n\n      if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {\n        return cachedToken.headers;\n      }\n\n      var iat = Math.floor(Date.now() / 1000);\n      var exp = JWTAccess.getExpirationTime(iat);\n      var defaultClaims; // Turn scopes into space-separated string\n\n      if (Array.isArray(scopes)) {\n        scopes = scopes.join(' ');\n      } // If scopes are specified, sign with scopes\n\n\n      if (scopes) {\n        defaultClaims = {\n          iss: this.email,\n          sub: this.email,\n          scope: scopes,\n          exp: exp,\n          iat: iat\n        };\n      } else {\n        defaultClaims = {\n          iss: this.email,\n          sub: this.email,\n          aud: url,\n          exp: exp,\n          iat: iat\n        };\n      } // if additionalClaims are provided, ensure they do not collide with\n      // other required claims.\n\n\n      if (additionalClaims) {\n        for (var claim in defaultClaims) {\n          if (additionalClaims[claim]) {\n            throw new Error(\"The '\".concat(claim, \"' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.\"));\n          }\n        }\n      }\n\n      var header = this.keyId ? _objectSpread(_objectSpread({}, DEFAULT_HEADER), {}, {\n        kid: this.keyId\n      }) : DEFAULT_HEADER;\n      var payload = Object.assign(defaultClaims, additionalClaims); // Sign the jwt and add it to the cache\n\n      var signedJWT = jws.sign({\n        header: header,\n        payload: payload,\n        secret: this.key\n      });\n      var headers = {\n        Authorization: \"Bearer \".concat(signedJWT)\n      };\n      this.cache.set(key, {\n        expiration: exp * 1000,\n        headers: headers\n      });\n      return headers;\n    }\n    /**\r\n     * Returns an expiration time for the JWT token.\r\n     *\r\n     * @param iat The issued at time for the JWT.\r\n     * @returns An expiration time for the JWT.\r\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value:\n    /**\r\n     * Create a JWTAccess credentials instance using the given input options.\r\n     * @param json The input object.\r\n     */\n    function fromJSON(json) {\n      if (!json) {\n        throw new Error('Must pass in a JSON object containing the service account auth settings.');\n      }\n\n      if (!json.client_email) {\n        throw new Error('The incoming JSON object does not contain a client_email field');\n      }\n\n      if (!json.private_key) {\n        throw new Error('The incoming JSON object does not contain a private_key field');\n      } // Extract the relevant information from the json key file.\n\n\n      this.email = json.client_email;\n      this.key = json.private_key;\n      this.keyId = json.private_key_id;\n      this.projectId = json.project_id;\n    }\n  }, {\n    key: \"fromStream\",\n    value: function fromStream(inputStream, callback) {\n      if (callback) {\n        this.fromStreamAsync(inputStream).then(function () {\n          return callback();\n        }, callback);\n      } else {\n        return this.fromStreamAsync(inputStream);\n      }\n    }\n  }, {\n    key: \"fromStreamAsync\",\n    value: function fromStreamAsync(inputStream) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (!inputStream) {\n          reject(new Error('Must pass in a stream containing the service account auth settings.'));\n        }\n\n        var s = '';\n        inputStream.setEncoding('utf8').on('data', function (chunk) {\n          return s += chunk;\n        }).on('error', reject).on('end', function () {\n          try {\n            var data = JSON.parse(s);\n\n            _this.fromJSON(data);\n\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      });\n    }\n  }], [{\n    key: \"getExpirationTime\",\n    value: function getExpirationTime(iat) {\n      var exp = iat + 3600; // 3600 seconds = 1 hour\n\n      return exp;\n    }\n  }]);\n\n  return JWTAccess;\n}();\n\nexports.JWTAccess = JWTAccess;","map":{"version":3,"sources":["C:/Users/Enrique Niebles/Documents/Misi√≥n TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/google-auth-library/build/src/auth/jwtaccess.js"],"names":["Object","defineProperty","exports","value","JWTAccess","jws","require","LRU","DEFAULT_HEADER","alg","typ","email","key","keyId","eagerRefreshThresholdMillis","cache","max","maxAge","url","scopes","cacheKey","Array","isArray","length","join","Error","additionalClaims","getCachedKey","cachedToken","get","now","Date","expiration","headers","iat","Math","floor","exp","getExpirationTime","defaultClaims","iss","sub","scope","aud","claim","header","kid","payload","assign","signedJWT","sign","secret","Authorization","set","json","client_email","private_key","private_key_id","projectId","project_id","inputStream","callback","fromStreamAsync","then","Promise","resolve","reject","s","setEncoding","on","chunk","data","JSON","parse","fromJSON","err"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Copyright 2015 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.JWTAccess = void 0;\r\nconst jws = require(\"jws\");\r\nconst LRU = require(\"lru-cache\");\r\nconst DEFAULT_HEADER = {\r\n    alg: 'RS256',\r\n    typ: 'JWT',\r\n};\r\nclass JWTAccess {\r\n    /**\r\n     * JWTAccess service account credentials.\r\n     *\r\n     * Create a new access token by using the credential to create a new JWT token\r\n     * that's recognized as the access token.\r\n     *\r\n     * @param email the service account email address.\r\n     * @param key the private key that will be used to sign the token.\r\n     * @param keyId the ID of the private key used to sign the token.\r\n     */\r\n    constructor(email, key, keyId, eagerRefreshThresholdMillis) {\r\n        this.cache = new LRU({\r\n            max: 500,\r\n            maxAge: 60 * 60 * 1000,\r\n        });\r\n        this.email = email;\r\n        this.key = key;\r\n        this.keyId = keyId;\r\n        this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;\r\n    }\r\n    /**\r\n     * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url\r\n     *\r\n     * @param url The URI being authorized.\r\n     * @param scopes The scope or scopes being authorized\r\n     * @returns A string that returns the cached key.\r\n     */\r\n    getCachedKey(url, scopes) {\r\n        let cacheKey = url;\r\n        if (scopes && Array.isArray(scopes) && scopes.length) {\r\n            cacheKey = url ? `${url}_${scopes.join('_')}` : `${scopes.join('_')}`;\r\n        }\r\n        else if (typeof scopes === 'string') {\r\n            cacheKey = url ? `${url}_${scopes}` : scopes;\r\n        }\r\n        if (!cacheKey) {\r\n            throw Error('Scopes or url must be provided');\r\n        }\r\n        return cacheKey;\r\n    }\r\n    /**\r\n     * Get a non-expired access token, after refreshing if necessary.\r\n     *\r\n     * @param url The URI being authorized.\r\n     * @param additionalClaims An object with a set of additional claims to\r\n     * include in the payload.\r\n     * @returns An object that includes the authorization header.\r\n     */\r\n    getRequestHeaders(url, additionalClaims, scopes) {\r\n        // Return cached authorization headers, unless we are within\r\n        // eagerRefreshThresholdMillis ms of them expiring:\r\n        const key = this.getCachedKey(url, scopes);\r\n        const cachedToken = this.cache.get(key);\r\n        const now = Date.now();\r\n        if (cachedToken &&\r\n            cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {\r\n            return cachedToken.headers;\r\n        }\r\n        const iat = Math.floor(Date.now() / 1000);\r\n        const exp = JWTAccess.getExpirationTime(iat);\r\n        let defaultClaims;\r\n        // Turn scopes into space-separated string\r\n        if (Array.isArray(scopes)) {\r\n            scopes = scopes.join(' ');\r\n        }\r\n        // If scopes are specified, sign with scopes\r\n        if (scopes) {\r\n            defaultClaims = {\r\n                iss: this.email,\r\n                sub: this.email,\r\n                scope: scopes,\r\n                exp,\r\n                iat,\r\n            };\r\n        }\r\n        else {\r\n            defaultClaims = {\r\n                iss: this.email,\r\n                sub: this.email,\r\n                aud: url,\r\n                exp,\r\n                iat,\r\n            };\r\n        }\r\n        // if additionalClaims are provided, ensure they do not collide with\r\n        // other required claims.\r\n        if (additionalClaims) {\r\n            for (const claim in defaultClaims) {\r\n                if (additionalClaims[claim]) {\r\n                    throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\r\n                }\r\n            }\r\n        }\r\n        const header = this.keyId\r\n            ? { ...DEFAULT_HEADER, kid: this.keyId }\r\n            : DEFAULT_HEADER;\r\n        const payload = Object.assign(defaultClaims, additionalClaims);\r\n        // Sign the jwt and add it to the cache\r\n        const signedJWT = jws.sign({ header, payload, secret: this.key });\r\n        const headers = { Authorization: `Bearer ${signedJWT}` };\r\n        this.cache.set(key, {\r\n            expiration: exp * 1000,\r\n            headers,\r\n        });\r\n        return headers;\r\n    }\r\n    /**\r\n     * Returns an expiration time for the JWT token.\r\n     *\r\n     * @param iat The issued at time for the JWT.\r\n     * @returns An expiration time for the JWT.\r\n     */\r\n    static getExpirationTime(iat) {\r\n        const exp = iat + 3600; // 3600 seconds = 1 hour\r\n        return exp;\r\n    }\r\n    /**\r\n     * Create a JWTAccess credentials instance using the given input options.\r\n     * @param json The input object.\r\n     */\r\n    fromJSON(json) {\r\n        if (!json) {\r\n            throw new Error('Must pass in a JSON object containing the service account auth settings.');\r\n        }\r\n        if (!json.client_email) {\r\n            throw new Error('The incoming JSON object does not contain a client_email field');\r\n        }\r\n        if (!json.private_key) {\r\n            throw new Error('The incoming JSON object does not contain a private_key field');\r\n        }\r\n        // Extract the relevant information from the json key file.\r\n        this.email = json.client_email;\r\n        this.key = json.private_key;\r\n        this.keyId = json.private_key_id;\r\n        this.projectId = json.project_id;\r\n    }\r\n    fromStream(inputStream, callback) {\r\n        if (callback) {\r\n            this.fromStreamAsync(inputStream).then(() => callback(), callback);\r\n        }\r\n        else {\r\n            return this.fromStreamAsync(inputStream);\r\n        }\r\n    }\r\n    fromStreamAsync(inputStream) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!inputStream) {\r\n                reject(new Error('Must pass in a stream containing the service account auth settings.'));\r\n            }\r\n            let s = '';\r\n            inputStream\r\n                .setEncoding('utf8')\r\n                .on('data', chunk => (s += chunk))\r\n                .on('error', reject)\r\n                .on('end', () => {\r\n                try {\r\n                    const data = JSON.parse(s);\r\n                    this.fromJSON(data);\r\n                    resolve();\r\n                }\r\n                catch (err) {\r\n                    reject(err);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.JWTAccess = JWTAccess;\r\n//# sourceMappingURL=jwtaccess.js.map"]},"metadata":{},"sourceType":"script"}