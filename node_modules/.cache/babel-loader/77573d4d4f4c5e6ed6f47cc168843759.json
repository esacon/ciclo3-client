{"ast":null,"code":"\"use strict\"; // Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\n\nconst child_process_1 = require(\"child_process\");\n\nconst fs = require(\"fs\");\n\nconst gcpMetadata = require(\"gcp-metadata\");\n\nconst os = require(\"os\");\n\nconst path = require(\"path\");\n\nconst crypto_1 = require(\"../crypto/crypto\");\n\nconst transporters_1 = require(\"../transporters\");\n\nconst computeclient_1 = require(\"./computeclient\");\n\nconst idtokenclient_1 = require(\"./idtokenclient\");\n\nconst envDetect_1 = require(\"./envDetect\");\n\nconst jwtclient_1 = require(\"./jwtclient\");\n\nconst refreshclient_1 = require(\"./refreshclient\");\n\nconst externalclient_1 = require(\"./externalclient\");\n\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\n\nclass GoogleAuth {\n  constructor(opts) {\n    /**\r\n     * Caches a value indicating whether the auth layer is running on Google\r\n     * Compute Engine.\r\n     * @private\r\n     */\n    this.checkIsGCE = undefined; // To save the contents of the JSON credential file\n\n    this.jsonContent = null;\n    this.cachedCredential = null;\n    opts = opts || {};\n    this._cachedProjectId = opts.projectId || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.jsonContent = opts.credentials || null;\n    this.clientOptions = opts.clientOptions;\n  } // Note:  this properly is only public to satisify unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n\n\n  get isGCE() {\n    return this.checkIsGCE;\n  } // GAPIC client libraries should always use self-signed JWTs. The following\n  // variables are set on the JWT client in order to indicate the type of library,\n  // and sign the JWT with the correct audience and scopes (if not supplied).\n\n\n  setGapicJWTValues(client) {\n    client.defaultServicePath = this.defaultServicePath;\n    client.useJWTAccessWithScope = this.useJWTAccessWithScope;\n    client.defaultScopes = this.defaultScopes;\n  }\n\n  getProjectId(callback) {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  getProjectIdAsync() {\n    if (this._cachedProjectId) {\n      return Promise.resolve(this._cachedProjectId);\n    } // In implicit case, supports three environments. In order of precedence,\n    // the implicit environments are:\n    // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n    // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n    // - Cloud SDK: `gcloud config config-helper --format json`\n    // - GCE project ID from metadata server)\n\n\n    if (!this._getDefaultProjectIdPromise) {\n      // TODO: refactor the below code so that it doesn't mix and match\n      // promises and async/await.\n      this._getDefaultProjectIdPromise = new Promise( // eslint-disable-next-line no-async-promise-executor\n      async (resolve, reject) => {\n        try {\n          const projectId = this.getProductionProjectId() || (await this.getFileProjectId()) || (await this.getDefaultServiceProjectId()) || (await this.getGCEProjectId()) || (await this.getExternalAccountClientProjectId());\n          this._cachedProjectId = projectId;\n\n          if (!projectId) {\n            throw new Error('Unable to detect a Project Id in the current environment. \\n' + 'To learn more about authentication and Google APIs, visit: \\n' + 'https://cloud.google.com/docs/authentication/getting-started');\n          }\n\n          resolve(projectId);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }\n\n    return this._getDefaultProjectIdPromise;\n  }\n  /**\r\n   * @returns Any scopes (user-specified or default scopes specified by the\r\n   *   client library) that need to be set on the current Auth client.\r\n   */\n\n\n  getAnyScopes() {\n    return this.scopes || this.defaultScopes;\n  }\n\n  getApplicationDefault(optionsOrCallback = {}, callback) {\n    let options;\n\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n\n  async getApplicationDefaultAsync(options = {}) {\n    // If we've already got a cached credential, just return it.\n    if (this.cachedCredential) {\n      return {\n        credential: this.cachedCredential,\n        projectId: await this.getProjectIdAsync()\n      };\n    }\n\n    let credential;\n    let projectId; // Check for the existence of a local environment variable pointing to the\n    // location of the credential file. This is typically used in local\n    // developer scenarios.\n\n    credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n\n    if (credential) {\n      if (credential instanceof jwtclient_1.JWT) {\n        credential.scopes = this.scopes;\n      } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n        credential.scopes = this.getAnyScopes();\n      }\n\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {\n        credential,\n        projectId\n      };\n    } // Look in the well-known credential file location.\n\n\n    credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n\n    if (credential) {\n      if (credential instanceof jwtclient_1.JWT) {\n        credential.scopes = this.scopes;\n      } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n        credential.scopes = this.getAnyScopes();\n      }\n\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {\n        credential,\n        projectId\n      };\n    } // Determine if we're running on GCE.\n\n\n    let isGCE;\n\n    try {\n      isGCE = await this._checkIsGCE();\n    } catch (e) {\n      e.message = `Unexpected error determining execution environment: ${e.message}`;\n      throw e;\n    }\n\n    if (!isGCE) {\n      // We failed to find the default credentials. Bail out with an error.\n      throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n    } // For GCE, just return a default ComputeClient. It will take care of\n    // the rest.\n\n\n    options.scopes = this.getAnyScopes();\n    this.cachedCredential = new computeclient_1.Compute(options);\n    projectId = await this.getProjectId();\n    return {\n      projectId,\n      credential: this.cachedCredential\n    };\n  }\n  /**\r\n   * Determines whether the auth layer is running on Google Compute Engine.\r\n   * @returns A promise that resolves with the boolean.\r\n   * @api private\r\n   */\n\n\n  async _checkIsGCE() {\n    if (this.checkIsGCE === undefined) {\n      this.checkIsGCE = await gcpMetadata.isAvailable();\n    }\n\n    return this.checkIsGCE;\n  }\n  /**\r\n   * Attempts to load default credentials from the environment variable path..\r\n   * @returns Promise that resolves with the OAuth2Client or null.\r\n   * @api private\r\n   */\n\n\n  async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n    const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] || process.env['google_application_credentials'];\n\n    if (!credentialsPath || credentialsPath.length === 0) {\n      return null;\n    }\n\n    try {\n      return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n    } catch (e) {\n      e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n      throw e;\n    }\n  }\n  /**\r\n   * Attempts to load default credentials from a well-known file location\r\n   * @return Promise that resolves with the OAuth2Client or null.\r\n   * @api private\r\n   */\n\n\n  async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n    // First, figure out the location of the file, depending upon the OS type.\n    let location = null;\n\n    if (this._isWindows()) {\n      // Windows\n      location = process.env['APPDATA'];\n    } else {\n      // Linux or Mac\n      const home = process.env['HOME'];\n\n      if (home) {\n        location = path.join(home, '.config');\n      }\n    } // If we found the root path, expand it.\n\n\n    if (location) {\n      location = path.join(location, 'gcloud', 'application_default_credentials.json');\n\n      if (!fs.existsSync(location)) {\n        location = null;\n      }\n    } // The file does not exist.\n\n\n    if (!location) {\n      return null;\n    } // The file seems to exist. Try to use it.\n\n\n    const client = await this._getApplicationCredentialsFromFilePath(location, options);\n    return client;\n  }\n  /**\r\n   * Attempts to load default credentials from a file at the given path..\r\n   * @param filePath The path to the file to read.\r\n   * @returns Promise that resolves with the OAuth2Client\r\n   * @api private\r\n   */\n\n\n  async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n    // Make sure the path looks like a string.\n    if (!filePath || filePath.length === 0) {\n      throw new Error('The file path is invalid.');\n    } // Make sure there is a file at the path. lstatSync will throw if there is\n    // nothing there.\n\n\n    try {\n      // Resolve path to actual file in case of symlink. Expect a thrown error\n      // if not resolvable.\n      filePath = fs.realpathSync(filePath);\n\n      if (!fs.lstatSync(filePath).isFile()) {\n        throw new Error();\n      }\n    } catch (err) {\n      err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n      throw err;\n    } // Now open a read stream on the file, and parse it.\n\n\n    const readStream = fs.createReadStream(filePath);\n    return this.fromStream(readStream, options);\n  }\n  /**\r\n   * Create a credentials instance using the given input options.\r\n   * @param json The input object.\r\n   * @param options The JWT or UserRefresh options for the client\r\n   * @returns JWT or UserRefresh Client with data\r\n   */\n\n\n  fromJSON(json, options) {\n    let client;\n\n    if (!json) {\n      throw new Error('Must pass in a JSON object containing the Google auth settings.');\n    }\n\n    options = options || {};\n\n    if (json.type === 'authorized_user') {\n      client = new refreshclient_1.UserRefreshClient(options);\n      client.fromJSON(json);\n    } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n      client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n      client.scopes = this.getAnyScopes();\n    } else {\n      options.scopes = this.scopes;\n      client = new jwtclient_1.JWT(options);\n      this.setGapicJWTValues(client);\n      client.fromJSON(json);\n    }\n\n    return client;\n  }\n  /**\r\n   * Return a JWT or UserRefreshClient from JavaScript object, caching both the\r\n   * object used to instantiate and the client.\r\n   * @param json The input object.\r\n   * @param options The JWT or UserRefresh options for the client\r\n   * @returns JWT or UserRefresh Client with data\r\n   */\n\n\n  _cacheClientFromJSON(json, options) {\n    let client; // create either a UserRefreshClient or JWT client.\n\n    options = options || {};\n\n    if (json.type === 'authorized_user') {\n      client = new refreshclient_1.UserRefreshClient(options);\n      client.fromJSON(json);\n    } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n      client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n      client.scopes = this.getAnyScopes();\n    } else {\n      options.scopes = this.scopes;\n      client = new jwtclient_1.JWT(options);\n      this.setGapicJWTValues(client);\n      client.fromJSON(json);\n    } // cache both raw data used to instantiate client and client itself.\n\n\n    this.jsonContent = json;\n    this.cachedCredential = client;\n    return this.cachedCredential;\n  }\n\n  fromStream(inputStream, optionsOrCallback = {}, callback) {\n    let options = {};\n\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n\n    if (callback) {\n      this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n\n  fromStreamAsync(inputStream, options) {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error('Must pass in a stream containing the Google auth settings.');\n      }\n\n      let s = '';\n      inputStream.setEncoding('utf8').on('error', reject).on('data', chunk => s += chunk).on('end', () => {\n        try {\n          try {\n            const data = JSON.parse(s);\n\n            const r = this._cacheClientFromJSON(data, options);\n\n            return resolve(r);\n          } catch (err) {\n            // If we failed parsing this.keyFileName, assume that it\n            // is a PEM or p12 certificate:\n            if (!this.keyFilename) throw err;\n            const client = new jwtclient_1.JWT({ ...this.clientOptions,\n              keyFile: this.keyFilename\n            });\n            this.cachedCredential = client;\n            this.setGapicJWTValues(client);\n            return resolve(client);\n          }\n        } catch (err) {\n          return reject(err);\n        }\n      });\n    });\n  }\n  /**\r\n   * Create a credentials instance using the given API key string.\r\n   * @param apiKey The API key string\r\n   * @param options An optional options object.\r\n   * @returns A JWT loaded from the key\r\n   */\n\n\n  fromAPIKey(apiKey, options) {\n    options = options || {};\n    const client = new jwtclient_1.JWT(options);\n    client.fromAPIKey(apiKey);\n    return client;\n  }\n  /**\r\n   * Determines whether the current operating system is Windows.\r\n   * @api private\r\n   */\n\n\n  _isWindows() {\n    const sys = os.platform();\n\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Run the Google Cloud SDK command that prints the default project ID\r\n   */\n\n\n  async getDefaultServiceProjectId() {\n    return new Promise(resolve => {\n      child_process_1.exec('gcloud config config-helper --format json', (err, stdout) => {\n        if (!err && stdout) {\n          try {\n            const projectId = JSON.parse(stdout).configuration.properties.core.project;\n            resolve(projectId);\n            return;\n          } catch (e) {// ignore errors\n          }\n        }\n\n        resolve(null);\n      });\n    });\n  }\n  /**\r\n   * Loads the project id from environment variables.\r\n   * @api private\r\n   */\n\n\n  getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'] || process.env['gcloud_project'] || process.env['google_cloud_project'];\n  }\n  /**\r\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\r\n   * @api private\r\n   */\n\n\n  async getFileProjectId() {\n    if (this.cachedCredential) {\n      // Try to read the project ID from the cached credentials file\n      return this.cachedCredential.projectId;\n    } // Ensure the projectId is loaded from the keyFile if available.\n\n\n    if (this.keyFilename) {\n      const creds = await this.getClient();\n\n      if (creds && creds.projectId) {\n        return creds.projectId;\n      }\n    } // Try to load a credentials file and read its project ID\n\n\n    const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n\n    if (r) {\n      return r.projectId;\n    } else {\n      return null;\n    }\n  }\n  /**\r\n   * Gets the project ID from external account client if available.\r\n   */\n\n\n  async getExternalAccountClientProjectId() {\n    if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n      return null;\n    }\n\n    const creds = await this.getClient(); // Do not suppress the underlying error, as the error could contain helpful\n    // information for debugging and fixing. This is especially true for\n    // external account creds as in order to get the project ID, the following\n    // operations have to succeed:\n    // 1. Valid credentials file should be supplied.\n    // 2. Ability to retrieve access tokens from STS token exchange API.\n    // 3. Ability to exchange for service account impersonated credentials (if\n    //    enabled).\n    // 4. Ability to get project info using the access token from step 2 or 3.\n    // Without surfacing the error, it is harder for developers to determine\n    // which step went wrong.\n\n    return await creds.getProjectId();\n  }\n  /**\r\n   * Gets the Compute Engine project ID if it can be inferred.\r\n   */\n\n\n  async getGCEProjectId() {\n    try {\n      const r = await gcpMetadata.project('project-id');\n      return r;\n    } catch (e) {\n      // Ignore any errors\n      return null;\n    }\n  }\n\n  getCredentials(callback) {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n\n  async getCredentialsAsync() {\n    await this.getClient();\n\n    if (this.jsonContent) {\n      const credential = {\n        client_email: this.jsonContent.client_email,\n        private_key: this.jsonContent.private_key\n      };\n      return credential;\n    }\n\n    const isGCE = await this._checkIsGCE();\n\n    if (!isGCE) {\n      throw new Error('Unknown error.');\n    } // For GCE, return the service account details from the metadata server\n    // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n    // The GCF metadata server doesn't respect querystring params if this / is\n    // not included.\n\n\n    const data = await gcpMetadata.instance({\n      property: 'service-accounts/',\n      params: {\n        recursive: 'true'\n      }\n    });\n\n    if (!data || !data.default || !data.default.email) {\n      throw new Error('Failure from metadata server.');\n    }\n\n    return {\n      client_email: data.default.email\n    };\n  }\n  /**\r\n   * Automatically obtain a client based on the provided configuration.  If no\r\n   * options were passed, use Application Default Credentials.\r\n   */\n\n\n  async getClient(options) {\n    if (options) {\n      throw new Error('Passing options to getClient is forbidden in v5.0.0. Use new GoogleAuth(opts) instead.');\n    }\n\n    if (!this.cachedCredential) {\n      if (this.jsonContent) {\n        this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n      } else if (this.keyFilename) {\n        const filePath = path.resolve(this.keyFilename);\n        const stream = fs.createReadStream(filePath);\n        await this.fromStreamAsync(stream, this.clientOptions);\n      } else {\n        await this.getApplicationDefaultAsync(this.clientOptions);\n      }\n    }\n\n    return this.cachedCredential;\n  }\n  /**\r\n   * Creates a client which will fetch an ID token for authorization.\r\n   * @param targetAudience the audience for the fetched ID token.\r\n   * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\r\n   */\n\n\n  async getIdTokenClient(targetAudience) {\n    const client = await this.getClient();\n\n    if (!('fetchIdToken' in client)) {\n      throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\n    }\n\n    return new idtokenclient_1.IdTokenClient({\n      targetAudience,\n      idTokenProvider: client\n    });\n  }\n  /**\r\n   * Automatically obtain application default credentials, and return\r\n   * an access token for making requests.\r\n   */\n\n\n  async getAccessToken() {\n    const client = await this.getClient();\n    return (await client.getAccessToken()).token;\n  }\n  /**\r\n   * Obtain the HTTP headers that will provide authorization for a given\r\n   * request.\r\n   */\n\n\n  async getRequestHeaders(url) {\n    const client = await this.getClient();\n    return client.getRequestHeaders(url);\n  }\n  /**\r\n   * Obtain credentials for a request, then attach the appropriate headers to\r\n   * the request options.\r\n   * @param opts Axios or Request options on which to attach the headers\r\n   */\n\n\n  async authorizeRequest(opts) {\n    opts = opts || {};\n    const url = opts.url || opts.uri;\n    const client = await this.getClient();\n    const headers = await client.getRequestHeaders(url);\n    opts.headers = Object.assign(opts.headers || {}, headers);\n    return opts;\n  }\n  /**\r\n   * Automatically obtain application default credentials, and make an\r\n   * HTTP request using the given options.\r\n   * @param opts Axios request options for the HTTP request.\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  async request(opts) {\n    const client = await this.getClient();\n    return client.request(opts);\n  }\n  /**\r\n   * Determine the compute environment in which the code is running.\r\n   */\n\n\n  getEnv() {\n    return envDetect_1.getEnv();\n  }\n  /**\r\n   * Sign the given data with the current private key, or go out\r\n   * to the IAM API to sign it.\r\n   * @param data The data to be signed.\r\n   */\n\n\n  async sign(data) {\n    const client = await this.getClient();\n    const crypto = crypto_1.createCrypto();\n\n    if (client instanceof jwtclient_1.JWT && client.key) {\n      const sign = await crypto.sign(client.key, data);\n      return sign;\n    } // signBlob requires a service account email and the underlying\n    // access token to have iam.serviceAccounts.signBlob permission\n    // on the specified resource name.\n    // The \"Service Account Token Creator\" role should cover this.\n    // As a result external account credentials can support this\n    // operation when service account impersonation is enabled.\n\n\n    if (client instanceof baseexternalclient_1.BaseExternalAccountClient && client.getServiceAccountEmail()) {\n      return this.signBlob(crypto, client.getServiceAccountEmail(), data);\n    }\n\n    const projectId = await this.getProjectId();\n\n    if (!projectId) {\n      throw new Error('Cannot sign data without a project ID.');\n    }\n\n    const creds = await this.getCredentials();\n\n    if (!creds.client_email) {\n      throw new Error('Cannot sign data without `client_email`.');\n    }\n\n    return this.signBlob(crypto, creds.client_email, data);\n  }\n\n  async signBlob(crypto, emailOrUniqueId, data) {\n    const url = 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/' + `${emailOrUniqueId}:signBlob`;\n    const res = await this.request({\n      method: 'POST',\n      url,\n      data: {\n        payload: crypto.encodeBase64StringUtf8(data)\n      }\n    });\n    return res.data.signedBlob;\n  }\n\n}\n\nexports.GoogleAuth = GoogleAuth;\n/**\r\n * Export DefaultTransporter as a static property of the class.\r\n */\n\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;","map":{"version":3,"sources":["C:/Users/Enrique Niebles/Documents/Misión TIC 2021/Ciclo 3 - Desarrollo Software/Despliegue/grupo4/react/node_modules/google-auth-library/build/src/auth/googleauth.js"],"names":["Object","defineProperty","exports","value","GoogleAuth","CLOUD_SDK_CLIENT_ID","child_process_1","require","fs","gcpMetadata","os","path","crypto_1","transporters_1","computeclient_1","idtokenclient_1","envDetect_1","jwtclient_1","refreshclient_1","externalclient_1","baseexternalclient_1","constructor","opts","checkIsGCE","undefined","jsonContent","cachedCredential","_cachedProjectId","projectId","keyFilename","keyFile","scopes","credentials","clientOptions","isGCE","setGapicJWTValues","client","defaultServicePath","useJWTAccessWithScope","defaultScopes","getProjectId","callback","getProjectIdAsync","then","r","Promise","resolve","_getDefaultProjectIdPromise","reject","getProductionProjectId","getFileProjectId","getDefaultServiceProjectId","getGCEProjectId","getExternalAccountClientProjectId","Error","e","getAnyScopes","getApplicationDefault","optionsOrCallback","options","getApplicationDefaultAsync","credential","_tryGetApplicationCredentialsFromEnvironmentVariable","JWT","BaseExternalAccountClient","_tryGetApplicationCredentialsFromWellKnownFile","_checkIsGCE","message","Compute","isAvailable","credentialsPath","process","env","length","_getApplicationCredentialsFromFilePath","location","_isWindows","home","join","existsSync","filePath","realpathSync","lstatSync","isFile","err","readStream","createReadStream","fromStream","fromJSON","json","type","UserRefreshClient","EXTERNAL_ACCOUNT_TYPE","ExternalAccountClient","_cacheClientFromJSON","inputStream","fromStreamAsync","s","setEncoding","on","chunk","data","JSON","parse","fromAPIKey","apiKey","sys","platform","substring","toLowerCase","exec","stdout","configuration","properties","core","project","creds","getClient","getCredentials","getCredentialsAsync","client_email","private_key","instance","property","params","recursive","default","email","stream","getIdTokenClient","targetAudience","IdTokenClient","idTokenProvider","getAccessToken","token","getRequestHeaders","url","authorizeRequest","uri","headers","assign","request","getEnv","sign","crypto","createCrypto","key","getServiceAccountEmail","signBlob","emailOrUniqueId","res","method","payload","encodeBase64StringUtf8","signedBlob","DefaultTransporter"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Copyright 2019 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\r\nconst child_process_1 = require(\"child_process\");\r\nconst fs = require(\"fs\");\r\nconst gcpMetadata = require(\"gcp-metadata\");\r\nconst os = require(\"os\");\r\nconst path = require(\"path\");\r\nconst crypto_1 = require(\"../crypto/crypto\");\r\nconst transporters_1 = require(\"../transporters\");\r\nconst computeclient_1 = require(\"./computeclient\");\r\nconst idtokenclient_1 = require(\"./idtokenclient\");\r\nconst envDetect_1 = require(\"./envDetect\");\r\nconst jwtclient_1 = require(\"./jwtclient\");\r\nconst refreshclient_1 = require(\"./refreshclient\");\r\nconst externalclient_1 = require(\"./externalclient\");\r\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\r\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\r\nclass GoogleAuth {\r\n    constructor(opts) {\r\n        /**\r\n         * Caches a value indicating whether the auth layer is running on Google\r\n         * Compute Engine.\r\n         * @private\r\n         */\r\n        this.checkIsGCE = undefined;\r\n        // To save the contents of the JSON credential file\r\n        this.jsonContent = null;\r\n        this.cachedCredential = null;\r\n        opts = opts || {};\r\n        this._cachedProjectId = opts.projectId || null;\r\n        this.keyFilename = opts.keyFilename || opts.keyFile;\r\n        this.scopes = opts.scopes;\r\n        this.jsonContent = opts.credentials || null;\r\n        this.clientOptions = opts.clientOptions;\r\n    }\r\n    // Note:  this properly is only public to satisify unit tests.\r\n    // https://github.com/Microsoft/TypeScript/issues/5228\r\n    get isGCE() {\r\n        return this.checkIsGCE;\r\n    }\r\n    // GAPIC client libraries should always use self-signed JWTs. The following\r\n    // variables are set on the JWT client in order to indicate the type of library,\r\n    // and sign the JWT with the correct audience and scopes (if not supplied).\r\n    setGapicJWTValues(client) {\r\n        client.defaultServicePath = this.defaultServicePath;\r\n        client.useJWTAccessWithScope = this.useJWTAccessWithScope;\r\n        client.defaultScopes = this.defaultScopes;\r\n    }\r\n    getProjectId(callback) {\r\n        if (callback) {\r\n            this.getProjectIdAsync().then(r => callback(null, r), callback);\r\n        }\r\n        else {\r\n            return this.getProjectIdAsync();\r\n        }\r\n    }\r\n    getProjectIdAsync() {\r\n        if (this._cachedProjectId) {\r\n            return Promise.resolve(this._cachedProjectId);\r\n        }\r\n        // In implicit case, supports three environments. In order of precedence,\r\n        // the implicit environments are:\r\n        // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\r\n        // - GOOGLE_APPLICATION_CREDENTIALS JSON file\r\n        // - Cloud SDK: `gcloud config config-helper --format json`\r\n        // - GCE project ID from metadata server)\r\n        if (!this._getDefaultProjectIdPromise) {\r\n            // TODO: refactor the below code so that it doesn't mix and match\r\n            // promises and async/await.\r\n            this._getDefaultProjectIdPromise = new Promise(\r\n            // eslint-disable-next-line no-async-promise-executor\r\n            async (resolve, reject) => {\r\n                try {\r\n                    const projectId = this.getProductionProjectId() ||\r\n                        (await this.getFileProjectId()) ||\r\n                        (await this.getDefaultServiceProjectId()) ||\r\n                        (await this.getGCEProjectId()) ||\r\n                        (await this.getExternalAccountClientProjectId());\r\n                    this._cachedProjectId = projectId;\r\n                    if (!projectId) {\r\n                        throw new Error('Unable to detect a Project Id in the current environment. \\n' +\r\n                            'To learn more about authentication and Google APIs, visit: \\n' +\r\n                            'https://cloud.google.com/docs/authentication/getting-started');\r\n                    }\r\n                    resolve(projectId);\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            });\r\n        }\r\n        return this._getDefaultProjectIdPromise;\r\n    }\r\n    /**\r\n     * @returns Any scopes (user-specified or default scopes specified by the\r\n     *   client library) that need to be set on the current Auth client.\r\n     */\r\n    getAnyScopes() {\r\n        return this.scopes || this.defaultScopes;\r\n    }\r\n    getApplicationDefault(optionsOrCallback = {}, callback) {\r\n        let options;\r\n        if (typeof optionsOrCallback === 'function') {\r\n            callback = optionsOrCallback;\r\n        }\r\n        else {\r\n            options = optionsOrCallback;\r\n        }\r\n        if (callback) {\r\n            this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\r\n        }\r\n        else {\r\n            return this.getApplicationDefaultAsync(options);\r\n        }\r\n    }\r\n    async getApplicationDefaultAsync(options = {}) {\r\n        // If we've already got a cached credential, just return it.\r\n        if (this.cachedCredential) {\r\n            return {\r\n                credential: this.cachedCredential,\r\n                projectId: await this.getProjectIdAsync(),\r\n            };\r\n        }\r\n        let credential;\r\n        let projectId;\r\n        // Check for the existence of a local environment variable pointing to the\r\n        // location of the credential file. This is typically used in local\r\n        // developer scenarios.\r\n        credential =\r\n            await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\r\n        if (credential) {\r\n            if (credential instanceof jwtclient_1.JWT) {\r\n                credential.scopes = this.scopes;\r\n            }\r\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\r\n                credential.scopes = this.getAnyScopes();\r\n            }\r\n            this.cachedCredential = credential;\r\n            projectId = await this.getProjectId();\r\n            return { credential, projectId };\r\n        }\r\n        // Look in the well-known credential file location.\r\n        credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\r\n        if (credential) {\r\n            if (credential instanceof jwtclient_1.JWT) {\r\n                credential.scopes = this.scopes;\r\n            }\r\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\r\n                credential.scopes = this.getAnyScopes();\r\n            }\r\n            this.cachedCredential = credential;\r\n            projectId = await this.getProjectId();\r\n            return { credential, projectId };\r\n        }\r\n        // Determine if we're running on GCE.\r\n        let isGCE;\r\n        try {\r\n            isGCE = await this._checkIsGCE();\r\n        }\r\n        catch (e) {\r\n            e.message = `Unexpected error determining execution environment: ${e.message}`;\r\n            throw e;\r\n        }\r\n        if (!isGCE) {\r\n            // We failed to find the default credentials. Bail out with an error.\r\n            throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\r\n        }\r\n        // For GCE, just return a default ComputeClient. It will take care of\r\n        // the rest.\r\n        options.scopes = this.getAnyScopes();\r\n        this.cachedCredential = new computeclient_1.Compute(options);\r\n        projectId = await this.getProjectId();\r\n        return { projectId, credential: this.cachedCredential };\r\n    }\r\n    /**\r\n     * Determines whether the auth layer is running on Google Compute Engine.\r\n     * @returns A promise that resolves with the boolean.\r\n     * @api private\r\n     */\r\n    async _checkIsGCE() {\r\n        if (this.checkIsGCE === undefined) {\r\n            this.checkIsGCE = await gcpMetadata.isAvailable();\r\n        }\r\n        return this.checkIsGCE;\r\n    }\r\n    /**\r\n     * Attempts to load default credentials from the environment variable path..\r\n     * @returns Promise that resolves with the OAuth2Client or null.\r\n     * @api private\r\n     */\r\n    async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\r\n        const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] ||\r\n            process.env['google_application_credentials'];\r\n        if (!credentialsPath || credentialsPath.length === 0) {\r\n            return null;\r\n        }\r\n        try {\r\n            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\r\n        }\r\n        catch (e) {\r\n            e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Attempts to load default credentials from a well-known file location\r\n     * @return Promise that resolves with the OAuth2Client or null.\r\n     * @api private\r\n     */\r\n    async _tryGetApplicationCredentialsFromWellKnownFile(options) {\r\n        // First, figure out the location of the file, depending upon the OS type.\r\n        let location = null;\r\n        if (this._isWindows()) {\r\n            // Windows\r\n            location = process.env['APPDATA'];\r\n        }\r\n        else {\r\n            // Linux or Mac\r\n            const home = process.env['HOME'];\r\n            if (home) {\r\n                location = path.join(home, '.config');\r\n            }\r\n        }\r\n        // If we found the root path, expand it.\r\n        if (location) {\r\n            location = path.join(location, 'gcloud', 'application_default_credentials.json');\r\n            if (!fs.existsSync(location)) {\r\n                location = null;\r\n            }\r\n        }\r\n        // The file does not exist.\r\n        if (!location) {\r\n            return null;\r\n        }\r\n        // The file seems to exist. Try to use it.\r\n        const client = await this._getApplicationCredentialsFromFilePath(location, options);\r\n        return client;\r\n    }\r\n    /**\r\n     * Attempts to load default credentials from a file at the given path..\r\n     * @param filePath The path to the file to read.\r\n     * @returns Promise that resolves with the OAuth2Client\r\n     * @api private\r\n     */\r\n    async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\r\n        // Make sure the path looks like a string.\r\n        if (!filePath || filePath.length === 0) {\r\n            throw new Error('The file path is invalid.');\r\n        }\r\n        // Make sure there is a file at the path. lstatSync will throw if there is\r\n        // nothing there.\r\n        try {\r\n            // Resolve path to actual file in case of symlink. Expect a thrown error\r\n            // if not resolvable.\r\n            filePath = fs.realpathSync(filePath);\r\n            if (!fs.lstatSync(filePath).isFile()) {\r\n                throw new Error();\r\n            }\r\n        }\r\n        catch (err) {\r\n            err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\r\n            throw err;\r\n        }\r\n        // Now open a read stream on the file, and parse it.\r\n        const readStream = fs.createReadStream(filePath);\r\n        return this.fromStream(readStream, options);\r\n    }\r\n    /**\r\n     * Create a credentials instance using the given input options.\r\n     * @param json The input object.\r\n     * @param options The JWT or UserRefresh options for the client\r\n     * @returns JWT or UserRefresh Client with data\r\n     */\r\n    fromJSON(json, options) {\r\n        let client;\r\n        if (!json) {\r\n            throw new Error('Must pass in a JSON object containing the Google auth settings.');\r\n        }\r\n        options = options || {};\r\n        if (json.type === 'authorized_user') {\r\n            client = new refreshclient_1.UserRefreshClient(options);\r\n            client.fromJSON(json);\r\n        }\r\n        else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\r\n            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\r\n            client.scopes = this.getAnyScopes();\r\n        }\r\n        else {\r\n            options.scopes = this.scopes;\r\n            client = new jwtclient_1.JWT(options);\r\n            this.setGapicJWTValues(client);\r\n            client.fromJSON(json);\r\n        }\r\n        return client;\r\n    }\r\n    /**\r\n     * Return a JWT or UserRefreshClient from JavaScript object, caching both the\r\n     * object used to instantiate and the client.\r\n     * @param json The input object.\r\n     * @param options The JWT or UserRefresh options for the client\r\n     * @returns JWT or UserRefresh Client with data\r\n     */\r\n    _cacheClientFromJSON(json, options) {\r\n        let client;\r\n        // create either a UserRefreshClient or JWT client.\r\n        options = options || {};\r\n        if (json.type === 'authorized_user') {\r\n            client = new refreshclient_1.UserRefreshClient(options);\r\n            client.fromJSON(json);\r\n        }\r\n        else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\r\n            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\r\n            client.scopes = this.getAnyScopes();\r\n        }\r\n        else {\r\n            options.scopes = this.scopes;\r\n            client = new jwtclient_1.JWT(options);\r\n            this.setGapicJWTValues(client);\r\n            client.fromJSON(json);\r\n        }\r\n        // cache both raw data used to instantiate client and client itself.\r\n        this.jsonContent = json;\r\n        this.cachedCredential = client;\r\n        return this.cachedCredential;\r\n    }\r\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\r\n        let options = {};\r\n        if (typeof optionsOrCallback === 'function') {\r\n            callback = optionsOrCallback;\r\n        }\r\n        else {\r\n            options = optionsOrCallback;\r\n        }\r\n        if (callback) {\r\n            this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\r\n        }\r\n        else {\r\n            return this.fromStreamAsync(inputStream, options);\r\n        }\r\n    }\r\n    fromStreamAsync(inputStream, options) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!inputStream) {\r\n                throw new Error('Must pass in a stream containing the Google auth settings.');\r\n            }\r\n            let s = '';\r\n            inputStream\r\n                .setEncoding('utf8')\r\n                .on('error', reject)\r\n                .on('data', chunk => (s += chunk))\r\n                .on('end', () => {\r\n                try {\r\n                    try {\r\n                        const data = JSON.parse(s);\r\n                        const r = this._cacheClientFromJSON(data, options);\r\n                        return resolve(r);\r\n                    }\r\n                    catch (err) {\r\n                        // If we failed parsing this.keyFileName, assume that it\r\n                        // is a PEM or p12 certificate:\r\n                        if (!this.keyFilename)\r\n                            throw err;\r\n                        const client = new jwtclient_1.JWT({\r\n                            ...this.clientOptions,\r\n                            keyFile: this.keyFilename,\r\n                        });\r\n                        this.cachedCredential = client;\r\n                        this.setGapicJWTValues(client);\r\n                        return resolve(client);\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    return reject(err);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Create a credentials instance using the given API key string.\r\n     * @param apiKey The API key string\r\n     * @param options An optional options object.\r\n     * @returns A JWT loaded from the key\r\n     */\r\n    fromAPIKey(apiKey, options) {\r\n        options = options || {};\r\n        const client = new jwtclient_1.JWT(options);\r\n        client.fromAPIKey(apiKey);\r\n        return client;\r\n    }\r\n    /**\r\n     * Determines whether the current operating system is Windows.\r\n     * @api private\r\n     */\r\n    _isWindows() {\r\n        const sys = os.platform();\r\n        if (sys && sys.length >= 3) {\r\n            if (sys.substring(0, 3).toLowerCase() === 'win') {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Run the Google Cloud SDK command that prints the default project ID\r\n     */\r\n    async getDefaultServiceProjectId() {\r\n        return new Promise(resolve => {\r\n            child_process_1.exec('gcloud config config-helper --format json', (err, stdout) => {\r\n                if (!err && stdout) {\r\n                    try {\r\n                        const projectId = JSON.parse(stdout).configuration.properties.core.project;\r\n                        resolve(projectId);\r\n                        return;\r\n                    }\r\n                    catch (e) {\r\n                        // ignore errors\r\n                    }\r\n                }\r\n                resolve(null);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Loads the project id from environment variables.\r\n     * @api private\r\n     */\r\n    getProductionProjectId() {\r\n        return (process.env['GCLOUD_PROJECT'] ||\r\n            process.env['GOOGLE_CLOUD_PROJECT'] ||\r\n            process.env['gcloud_project'] ||\r\n            process.env['google_cloud_project']);\r\n    }\r\n    /**\r\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\r\n     * @api private\r\n     */\r\n    async getFileProjectId() {\r\n        if (this.cachedCredential) {\r\n            // Try to read the project ID from the cached credentials file\r\n            return this.cachedCredential.projectId;\r\n        }\r\n        // Ensure the projectId is loaded from the keyFile if available.\r\n        if (this.keyFilename) {\r\n            const creds = await this.getClient();\r\n            if (creds && creds.projectId) {\r\n                return creds.projectId;\r\n            }\r\n        }\r\n        // Try to load a credentials file and read its project ID\r\n        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\r\n        if (r) {\r\n            return r.projectId;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Gets the project ID from external account client if available.\r\n     */\r\n    async getExternalAccountClientProjectId() {\r\n        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\r\n            return null;\r\n        }\r\n        const creds = await this.getClient();\r\n        // Do not suppress the underlying error, as the error could contain helpful\r\n        // information for debugging and fixing. This is especially true for\r\n        // external account creds as in order to get the project ID, the following\r\n        // operations have to succeed:\r\n        // 1. Valid credentials file should be supplied.\r\n        // 2. Ability to retrieve access tokens from STS token exchange API.\r\n        // 3. Ability to exchange for service account impersonated credentials (if\r\n        //    enabled).\r\n        // 4. Ability to get project info using the access token from step 2 or 3.\r\n        // Without surfacing the error, it is harder for developers to determine\r\n        // which step went wrong.\r\n        return await creds.getProjectId();\r\n    }\r\n    /**\r\n     * Gets the Compute Engine project ID if it can be inferred.\r\n     */\r\n    async getGCEProjectId() {\r\n        try {\r\n            const r = await gcpMetadata.project('project-id');\r\n            return r;\r\n        }\r\n        catch (e) {\r\n            // Ignore any errors\r\n            return null;\r\n        }\r\n    }\r\n    getCredentials(callback) {\r\n        if (callback) {\r\n            this.getCredentialsAsync().then(r => callback(null, r), callback);\r\n        }\r\n        else {\r\n            return this.getCredentialsAsync();\r\n        }\r\n    }\r\n    async getCredentialsAsync() {\r\n        await this.getClient();\r\n        if (this.jsonContent) {\r\n            const credential = {\r\n                client_email: this.jsonContent.client_email,\r\n                private_key: this.jsonContent.private_key,\r\n            };\r\n            return credential;\r\n        }\r\n        const isGCE = await this._checkIsGCE();\r\n        if (!isGCE) {\r\n            throw new Error('Unknown error.');\r\n        }\r\n        // For GCE, return the service account details from the metadata server\r\n        // NOTE: The trailing '/' at the end of service-accounts/ is very important!\r\n        // The GCF metadata server doesn't respect querystring params if this / is\r\n        // not included.\r\n        const data = await gcpMetadata.instance({\r\n            property: 'service-accounts/',\r\n            params: { recursive: 'true' },\r\n        });\r\n        if (!data || !data.default || !data.default.email) {\r\n            throw new Error('Failure from metadata server.');\r\n        }\r\n        return { client_email: data.default.email };\r\n    }\r\n    /**\r\n     * Automatically obtain a client based on the provided configuration.  If no\r\n     * options were passed, use Application Default Credentials.\r\n     */\r\n    async getClient(options) {\r\n        if (options) {\r\n            throw new Error('Passing options to getClient is forbidden in v5.0.0. Use new GoogleAuth(opts) instead.');\r\n        }\r\n        if (!this.cachedCredential) {\r\n            if (this.jsonContent) {\r\n                this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\r\n            }\r\n            else if (this.keyFilename) {\r\n                const filePath = path.resolve(this.keyFilename);\r\n                const stream = fs.createReadStream(filePath);\r\n                await this.fromStreamAsync(stream, this.clientOptions);\r\n            }\r\n            else {\r\n                await this.getApplicationDefaultAsync(this.clientOptions);\r\n            }\r\n        }\r\n        return this.cachedCredential;\r\n    }\r\n    /**\r\n     * Creates a client which will fetch an ID token for authorization.\r\n     * @param targetAudience the audience for the fetched ID token.\r\n     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\r\n     */\r\n    async getIdTokenClient(targetAudience) {\r\n        const client = await this.getClient();\r\n        if (!('fetchIdToken' in client)) {\r\n            throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\r\n        }\r\n        return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });\r\n    }\r\n    /**\r\n     * Automatically obtain application default credentials, and return\r\n     * an access token for making requests.\r\n     */\r\n    async getAccessToken() {\r\n        const client = await this.getClient();\r\n        return (await client.getAccessToken()).token;\r\n    }\r\n    /**\r\n     * Obtain the HTTP headers that will provide authorization for a given\r\n     * request.\r\n     */\r\n    async getRequestHeaders(url) {\r\n        const client = await this.getClient();\r\n        return client.getRequestHeaders(url);\r\n    }\r\n    /**\r\n     * Obtain credentials for a request, then attach the appropriate headers to\r\n     * the request options.\r\n     * @param opts Axios or Request options on which to attach the headers\r\n     */\r\n    async authorizeRequest(opts) {\r\n        opts = opts || {};\r\n        const url = opts.url || opts.uri;\r\n        const client = await this.getClient();\r\n        const headers = await client.getRequestHeaders(url);\r\n        opts.headers = Object.assign(opts.headers || {}, headers);\r\n        return opts;\r\n    }\r\n    /**\r\n     * Automatically obtain application default credentials, and make an\r\n     * HTTP request using the given options.\r\n     * @param opts Axios request options for the HTTP request.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    async request(opts) {\r\n        const client = await this.getClient();\r\n        return client.request(opts);\r\n    }\r\n    /**\r\n     * Determine the compute environment in which the code is running.\r\n     */\r\n    getEnv() {\r\n        return envDetect_1.getEnv();\r\n    }\r\n    /**\r\n     * Sign the given data with the current private key, or go out\r\n     * to the IAM API to sign it.\r\n     * @param data The data to be signed.\r\n     */\r\n    async sign(data) {\r\n        const client = await this.getClient();\r\n        const crypto = crypto_1.createCrypto();\r\n        if (client instanceof jwtclient_1.JWT && client.key) {\r\n            const sign = await crypto.sign(client.key, data);\r\n            return sign;\r\n        }\r\n        // signBlob requires a service account email and the underlying\r\n        // access token to have iam.serviceAccounts.signBlob permission\r\n        // on the specified resource name.\r\n        // The \"Service Account Token Creator\" role should cover this.\r\n        // As a result external account credentials can support this\r\n        // operation when service account impersonation is enabled.\r\n        if (client instanceof baseexternalclient_1.BaseExternalAccountClient &&\r\n            client.getServiceAccountEmail()) {\r\n            return this.signBlob(crypto, client.getServiceAccountEmail(), data);\r\n        }\r\n        const projectId = await this.getProjectId();\r\n        if (!projectId) {\r\n            throw new Error('Cannot sign data without a project ID.');\r\n        }\r\n        const creds = await this.getCredentials();\r\n        if (!creds.client_email) {\r\n            throw new Error('Cannot sign data without `client_email`.');\r\n        }\r\n        return this.signBlob(crypto, creds.client_email, data);\r\n    }\r\n    async signBlob(crypto, emailOrUniqueId, data) {\r\n        const url = 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/' +\r\n            `${emailOrUniqueId}:signBlob`;\r\n        const res = await this.request({\r\n            method: 'POST',\r\n            url,\r\n            data: {\r\n                payload: crypto.encodeBase64StringUtf8(data),\r\n            },\r\n        });\r\n        return res.data.signedBlob;\r\n    }\r\n}\r\nexports.GoogleAuth = GoogleAuth;\r\n/**\r\n * Export DefaultTransporter as a static property of the class.\r\n */\r\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\r\n//# sourceMappingURL=googleauth.js.map"]},"metadata":{},"sourceType":"script"}