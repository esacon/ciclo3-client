{"ast":null,"code":"\"use strict\"; // Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _createForOfIteratorHelper = require(\"C:/Users/Enrique Niebles/Documents/Misi\\xF3n TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"C:/Users/Enrique Niebles/Documents/Misi\\xF3n TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/Enrique Niebles/Documents/Misi\\xF3n TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:/Users/Enrique Niebles/Documents/Misi\\xF3n TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Enrique Niebles/Documents/Misi\\xF3n TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/Enrique Niebles/Documents/Misi\\xF3n TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/Enrique Niebles/Documents/Misi\\xF3n TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\n\nvar querystring = require(\"querystring\");\n\nvar stream = require(\"stream\");\n\nvar formatEcdsa = require(\"ecdsa-sig-formatter\");\n\nvar crypto_1 = require(\"../crypto/crypto\");\n\nvar authclient_1 = require(\"./authclient\");\n\nvar loginticket_1 = require(\"./loginticket\");\n\nvar CodeChallengeMethod;\n\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\n\nvar CertificateFormat;\n\n(function (CertificateFormat) {\n  CertificateFormat[\"PEM\"] = \"PEM\";\n  CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\n\nvar OAuth2Client = /*#__PURE__*/function (_authclient_1$AuthCli) {\n  _inherits(OAuth2Client, _authclient_1$AuthCli);\n\n  var _super = _createSuper(OAuth2Client);\n\n  function OAuth2Client(optionsOrClientId, clientSecret, redirectUri) {\n    var _this;\n\n    _classCallCheck(this, OAuth2Client);\n\n    _this = _super.call(this);\n    _this.certificateCache = {};\n    _this.certificateExpiry = null;\n    _this.certificateCacheFormat = CertificateFormat.PEM;\n    _this.refreshTokenPromises = new Map();\n    var opts = optionsOrClientId && typeof optionsOrClientId === 'object' ? optionsOrClientId : {\n      clientId: optionsOrClientId,\n      clientSecret: clientSecret,\n      redirectUri: redirectUri\n    };\n    _this._clientId = opts.clientId;\n    _this._clientSecret = opts.clientSecret;\n    _this.redirectUri = opts.redirectUri;\n    _this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n    _this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n    return _this;\n  }\n  /**\r\n   * Generates URL for consent page landing.\r\n   * @param opts Options.\r\n   * @return URL to consent page.\r\n   */\n\n\n  _createClass(OAuth2Client, [{\n    key: \"generateAuthUrl\",\n    value: function generateAuthUrl() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (opts.code_challenge_method && !opts.code_challenge) {\n        throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n      }\n\n      opts.response_type = opts.response_type || 'code';\n      opts.client_id = opts.client_id || this._clientId;\n      opts.redirect_uri = opts.redirect_uri || this.redirectUri; // Allow scopes to be passed either as array or a string\n\n      if (opts.scope instanceof Array) {\n        opts.scope = opts.scope.join(' ');\n      }\n\n      var rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n      return rootUrl + '?' + querystring.stringify(opts);\n    }\n  }, {\n    key: \"generateCodeVerifier\",\n    value: function generateCodeVerifier() {\n      // To make the code compatible with browser SubtleCrypto we need to make\n      // this method async.\n      throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\r\n     * Convenience method to automatically generate a code_verifier, and its\r\n     * resulting SHA256. If used, this must be paired with a S256\r\n     * code_challenge_method.\r\n     *\r\n     * For a full example see:\r\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\r\n     */\n\n  }, {\n    key: \"generateCodeVerifierAsync\",\n    value: function () {\n      var _generateCodeVerifierAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var crypto, randomString, codeVerifier, unencodedCodeChallenge, codeChallenge;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // base64 encoding uses 6 bits per character, and we want to generate128\n                // characters. 6*128/8 = 96.\n                crypto = crypto_1.createCrypto();\n                randomString = crypto.randomBytesBase64(96); // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n                // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n                // swapping out a few chars.\n\n                codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-'); // Generate the base64 encoded SHA256\n\n                _context.next = 5;\n                return crypto.sha256DigestBase64(codeVerifier);\n\n              case 5:\n                unencodedCodeChallenge = _context.sent;\n                // We need to use base64UrlEncoding instead of standard base64\n                codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n                return _context.abrupt(\"return\", {\n                  codeVerifier: codeVerifier,\n                  codeChallenge: codeChallenge\n                });\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function generateCodeVerifierAsync() {\n        return _generateCodeVerifierAsync.apply(this, arguments);\n      }\n\n      return generateCodeVerifierAsync;\n    }()\n  }, {\n    key: \"getToken\",\n    value: function getToken(codeOrOptions, callback) {\n      var options = typeof codeOrOptions === 'string' ? {\n        code: codeOrOptions\n      } : codeOrOptions;\n\n      if (callback) {\n        this.getTokenAsync(options).then(function (r) {\n          return callback(null, r.tokens, r.res);\n        }, function (e) {\n          return callback(e, null, e.response);\n        });\n      } else {\n        return this.getTokenAsync(options);\n      }\n    }\n  }, {\n    key: \"getTokenAsync\",\n    value: function () {\n      var _getTokenAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {\n        var url, values, res, tokens;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n                values = {\n                  code: options.code,\n                  client_id: options.client_id || this._clientId,\n                  client_secret: this._clientSecret,\n                  redirect_uri: options.redirect_uri || this.redirectUri,\n                  grant_type: 'authorization_code',\n                  code_verifier: options.codeVerifier\n                };\n                _context2.next = 4;\n                return this.transporter.request({\n                  method: 'POST',\n                  url: url,\n                  data: querystring.stringify(values),\n                  headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                  }\n                });\n\n              case 4:\n                res = _context2.sent;\n                tokens = res.data;\n\n                if (res.data && res.data.expires_in) {\n                  tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n                  delete tokens.expires_in;\n                }\n\n                this.emit('tokens', tokens);\n                return _context2.abrupt(\"return\", {\n                  tokens: tokens,\n                  res: res\n                });\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getTokenAsync(_x) {\n        return _getTokenAsync.apply(this, arguments);\n      }\n\n      return getTokenAsync;\n    }()\n    /**\r\n     * Refreshes the access token.\r\n     * @param refresh_token Existing refresh token.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"refreshToken\",\n    value: function () {\n      var _refreshToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_refreshToken) {\n        var _this2 = this;\n\n        var p;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (_refreshToken) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.refreshTokenNoCache(_refreshToken));\n\n              case 2:\n                if (!this.refreshTokenPromises.has(_refreshToken)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.refreshTokenPromises.get(_refreshToken));\n\n              case 4:\n                p = this.refreshTokenNoCache(_refreshToken).then(function (r) {\n                  _this2.refreshTokenPromises.delete(_refreshToken);\n\n                  return r;\n                }, function (e) {\n                  _this2.refreshTokenPromises.delete(_refreshToken);\n\n                  throw e;\n                });\n                this.refreshTokenPromises.set(_refreshToken, p);\n                return _context3.abrupt(\"return\", p);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function refreshToken(_x2) {\n        return _refreshToken2.apply(this, arguments);\n      }\n\n      return refreshToken;\n    }()\n  }, {\n    key: \"refreshTokenNoCache\",\n    value: function () {\n      var _refreshTokenNoCache = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(refreshToken) {\n        var url, data, res, tokens;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (refreshToken) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('No refresh token is set.');\n\n              case 2:\n                url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n                data = {\n                  refresh_token: refreshToken,\n                  client_id: this._clientId,\n                  client_secret: this._clientSecret,\n                  grant_type: 'refresh_token'\n                }; // request for new token\n\n                _context4.next = 6;\n                return this.transporter.request({\n                  method: 'POST',\n                  url: url,\n                  data: querystring.stringify(data),\n                  headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                  }\n                });\n\n              case 6:\n                res = _context4.sent;\n                tokens = res.data; // TODO: de-duplicate this code from a few spots\n\n                if (res.data && res.data.expires_in) {\n                  tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n                  delete tokens.expires_in;\n                }\n\n                this.emit('tokens', tokens);\n                return _context4.abrupt(\"return\", {\n                  tokens: tokens,\n                  res: res\n                });\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function refreshTokenNoCache(_x3) {\n        return _refreshTokenNoCache.apply(this, arguments);\n      }\n\n      return refreshTokenNoCache;\n    }()\n  }, {\n    key: \"refreshAccessToken\",\n    value: function refreshAccessToken(callback) {\n      if (callback) {\n        this.refreshAccessTokenAsync().then(function (r) {\n          return callback(null, r.credentials, r.res);\n        }, callback);\n      } else {\n        return this.refreshAccessTokenAsync();\n      }\n    }\n  }, {\n    key: \"refreshAccessTokenAsync\",\n    value: function () {\n      var _refreshAccessTokenAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var r, tokens;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.refreshToken(this.credentials.refresh_token);\n\n              case 2:\n                r = _context5.sent;\n                tokens = r.tokens;\n                tokens.refresh_token = this.credentials.refresh_token;\n                this.credentials = tokens;\n                return _context5.abrupt(\"return\", {\n                  credentials: this.credentials,\n                  res: r.res\n                });\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function refreshAccessTokenAsync() {\n        return _refreshAccessTokenAsync.apply(this, arguments);\n      }\n\n      return refreshAccessTokenAsync;\n    }()\n  }, {\n    key: \"getAccessToken\",\n    value: function getAccessToken(callback) {\n      if (callback) {\n        this.getAccessTokenAsync().then(function (r) {\n          return callback(null, r.token, r.res);\n        }, callback);\n      } else {\n        return this.getAccessTokenAsync();\n      }\n    }\n  }, {\n    key: \"getAccessTokenAsync\",\n    value: function () {\n      var _getAccessTokenAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var shouldRefresh, refreshedAccessToken, r;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n\n                if (!shouldRefresh) {\n                  _context6.next = 21;\n                  break;\n                }\n\n                if (this.credentials.refresh_token) {\n                  _context6.next = 13;\n                  break;\n                }\n\n                if (!this.refreshHandler) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                _context6.next = 6;\n                return this.processAndValidateRefreshHandler();\n\n              case 6:\n                refreshedAccessToken = _context6.sent;\n\n                if (!(refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token)) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                this.setCredentials(refreshedAccessToken);\n                return _context6.abrupt(\"return\", {\n                  token: this.credentials.access_token\n                });\n\n              case 10:\n                _context6.next = 13;\n                break;\n\n              case 12:\n                throw new Error('No refresh token or refresh handler callback is set.');\n\n              case 13:\n                _context6.next = 15;\n                return this.refreshAccessTokenAsync();\n\n              case 15:\n                r = _context6.sent;\n\n                if (!(!r.credentials || r.credentials && !r.credentials.access_token)) {\n                  _context6.next = 18;\n                  break;\n                }\n\n                throw new Error('Could not refresh access token.');\n\n              case 18:\n                return _context6.abrupt(\"return\", {\n                  token: r.credentials.access_token,\n                  res: r.res\n                });\n\n              case 21:\n                return _context6.abrupt(\"return\", {\n                  token: this.credentials.access_token\n                });\n\n              case 22:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getAccessTokenAsync() {\n        return _getAccessTokenAsync.apply(this, arguments);\n      }\n\n      return getAccessTokenAsync;\n    }()\n    /**\r\n     * The main authentication interface.  It takes an optional url which when\r\n     * present is the endpoint being accessed, and returns a Promise which\r\n     * resolves with authorization header fields.\r\n     *\r\n     * In OAuth2Client, the result has the form:\r\n     * { Authorization: 'Bearer <access_token_value>' }\r\n     * @param url The optional url being authorized\r\n     */\n\n  }, {\n    key: \"getRequestHeaders\",\n    value: function () {\n      var _getRequestHeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(url) {\n        var headers;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.getRequestMetadataAsync(url);\n\n              case 2:\n                headers = _context7.sent.headers;\n                return _context7.abrupt(\"return\", headers);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getRequestHeaders(_x4) {\n        return _getRequestHeaders.apply(this, arguments);\n      }\n\n      return getRequestHeaders;\n    }()\n  }, {\n    key: \"getRequestMetadataAsync\",\n    value: function () {\n      var _getRequestMetadataAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8( // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      url) {\n        var thisCreds, _headers, refreshedAccessToken, _headers2, r, tokens, e, credentials, headers;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                thisCreds = this.credentials;\n\n                if (!(!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler)) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                throw new Error('No access, refresh token, API key or refresh handler callback is set.');\n\n              case 3:\n                if (!(thisCreds.access_token && !this.isTokenExpiring())) {\n                  _context8.next = 7;\n                  break;\n                }\n\n                thisCreds.token_type = thisCreds.token_type || 'Bearer';\n                _headers = {\n                  Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n                };\n                return _context8.abrupt(\"return\", {\n                  headers: this.addSharedMetadataHeaders(_headers)\n                });\n\n              case 7:\n                if (!this.refreshHandler) {\n                  _context8.next = 15;\n                  break;\n                }\n\n                _context8.next = 10;\n                return this.processAndValidateRefreshHandler();\n\n              case 10:\n                refreshedAccessToken = _context8.sent;\n\n                if (!(refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token)) {\n                  _context8.next = 15;\n                  break;\n                }\n\n                this.setCredentials(refreshedAccessToken);\n                _headers2 = {\n                  Authorization: 'Bearer ' + this.credentials.access_token\n                };\n                return _context8.abrupt(\"return\", {\n                  headers: this.addSharedMetadataHeaders(_headers2)\n                });\n\n              case 15:\n                if (!this.apiKey) {\n                  _context8.next = 17;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", {\n                  headers: {\n                    'X-Goog-Api-Key': this.apiKey\n                  }\n                });\n\n              case 17:\n                r = null;\n                tokens = null;\n                _context8.prev = 19;\n                _context8.next = 22;\n                return this.refreshToken(thisCreds.refresh_token);\n\n              case 22:\n                r = _context8.sent;\n                tokens = r.tokens;\n                _context8.next = 31;\n                break;\n\n              case 26:\n                _context8.prev = 26;\n                _context8.t0 = _context8[\"catch\"](19);\n                e = _context8.t0;\n\n                if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n                  e.message = \"Could not refresh access token: \".concat(e.message);\n                }\n\n                throw e;\n\n              case 31:\n                credentials = this.credentials;\n                credentials.token_type = credentials.token_type || 'Bearer';\n                tokens.refresh_token = credentials.refresh_token;\n                this.credentials = tokens;\n                headers = {\n                  Authorization: credentials.token_type + ' ' + tokens.access_token\n                };\n                return _context8.abrupt(\"return\", {\n                  headers: this.addSharedMetadataHeaders(headers),\n                  res: r.res\n                });\n\n              case 37:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[19, 26]]);\n      }));\n\n      function getRequestMetadataAsync(_x5) {\n        return _getRequestMetadataAsync.apply(this, arguments);\n      }\n\n      return getRequestMetadataAsync;\n    }()\n    /**\r\n     * Generates an URL to revoke the given token.\r\n     * @param token The existing token to be revoked.\r\n     */\n\n  }, {\n    key: \"revokeToken\",\n    value: function revokeToken(token, callback) {\n      var opts = {\n        url: OAuth2Client.getRevokeTokenUrl(token),\n        method: 'POST'\n      };\n\n      if (callback) {\n        this.transporter.request(opts).then(function (r) {\n          return callback(null, r);\n        }, callback);\n      } else {\n        return this.transporter.request(opts);\n      }\n    }\n  }, {\n    key: \"revokeCredentials\",\n    value: function revokeCredentials(callback) {\n      if (callback) {\n        this.revokeCredentialsAsync().then(function (res) {\n          return callback(null, res);\n        }, callback);\n      } else {\n        return this.revokeCredentialsAsync();\n      }\n    }\n  }, {\n    key: \"revokeCredentialsAsync\",\n    value: function () {\n      var _revokeCredentialsAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var token;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                token = this.credentials.access_token;\n                this.credentials = {};\n\n                if (!token) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", this.revokeToken(token));\n\n              case 6:\n                throw new Error('No access token to revoke.');\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function revokeCredentialsAsync() {\n        return _revokeCredentialsAsync.apply(this, arguments);\n      }\n\n      return revokeCredentialsAsync;\n    }()\n  }, {\n    key: \"request\",\n    value: function request(opts, callback) {\n      if (callback) {\n        this.requestAsync(opts).then(function (r) {\n          return callback(null, r);\n        }, function (e) {\n          return callback(e, e.response);\n        });\n      } else {\n        return this.requestAsync(opts);\n      }\n    }\n  }, {\n    key: \"requestAsync\",\n    value: function () {\n      var _requestAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(opts) {\n        var retry,\n            r2,\n            r,\n            res,\n            statusCode,\n            mayRequireRefresh,\n            mayRequireRefreshWithNoRefreshToken,\n            isReadableStream,\n            isAuthErr,\n            refreshedAccessToken,\n            _args10 = arguments;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                retry = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : false;\n                _context10.prev = 1;\n                _context10.next = 4;\n                return this.getRequestMetadataAsync(opts.url);\n\n              case 4:\n                r = _context10.sent;\n                opts.headers = opts.headers || {};\n\n                if (r.headers && r.headers['x-goog-user-project']) {\n                  opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n                }\n\n                if (r.headers && r.headers.Authorization) {\n                  opts.headers.Authorization = r.headers.Authorization;\n                }\n\n                if (this.apiKey) {\n                  opts.headers['X-Goog-Api-Key'] = this.apiKey;\n                }\n\n                _context10.next = 11;\n                return this.transporter.request(opts);\n\n              case 11:\n                r2 = _context10.sent;\n                _context10.next = 36;\n                break;\n\n              case 14:\n                _context10.prev = 14;\n                _context10.t0 = _context10[\"catch\"](1);\n                res = _context10.t0.response;\n\n                if (!res) {\n                  _context10.next = 35;\n                  break;\n                }\n\n                statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but either no\n                //   expiry_date was available or the forceRefreshOnFailure flag is set.\n                //   The absent expiry_date case can happen when developers stash the\n                //   access_token and refresh_token for later use, but the access_token\n                //   fails on the first try because it's expired. Some developers may\n                //   choose to enable forceRefreshOnFailure to mitigate time-related\n                //   errors.\n                // Or the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - No refresh_token was available\n                // - An access_token and a refreshHandler callback were available, but\n                //   either no expiry_date was available or the forceRefreshOnFailure\n                //   flag is set. The access_token fails on the first try because it's\n                //   expired. Some developers may choose to enable forceRefreshOnFailure\n                //   to mitigate time-related errors.\n\n                mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n                mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;\n                isReadableStream = res.config.data instanceof stream.Readable;\n                isAuthErr = statusCode === 401 || statusCode === 403;\n\n                if (!(!retry && isAuthErr && !isReadableStream && mayRequireRefresh)) {\n                  _context10.next = 29;\n                  break;\n                }\n\n                _context10.next = 26;\n                return this.refreshAccessTokenAsync();\n\n              case 26:\n                return _context10.abrupt(\"return\", this.requestAsync(opts, true));\n\n              case 29:\n                if (!(!retry && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken)) {\n                  _context10.next = 35;\n                  break;\n                }\n\n                _context10.next = 32;\n                return this.processAndValidateRefreshHandler();\n\n              case 32:\n                refreshedAccessToken = _context10.sent;\n\n                if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                  this.setCredentials(refreshedAccessToken);\n                }\n\n                return _context10.abrupt(\"return\", this.requestAsync(opts, true));\n\n              case 35:\n                throw _context10.t0;\n\n              case 36:\n                return _context10.abrupt(\"return\", r2);\n\n              case 37:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[1, 14]]);\n      }));\n\n      function requestAsync(_x6) {\n        return _requestAsync.apply(this, arguments);\n      }\n\n      return requestAsync;\n    }()\n  }, {\n    key: \"verifyIdToken\",\n    value: function verifyIdToken(options, callback) {\n      // This function used to accept two arguments instead of an options object.\n      // Check the types to help users upgrade with less pain.\n      // This check can be removed after a 2.0 release.\n      if (callback && typeof callback !== 'function') {\n        throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n      }\n\n      if (callback) {\n        this.verifyIdTokenAsync(options).then(function (r) {\n          return callback(null, r);\n        }, callback);\n      } else {\n        return this.verifyIdTokenAsync(options);\n      }\n    }\n  }, {\n    key: \"verifyIdTokenAsync\",\n    value: function () {\n      var _verifyIdTokenAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(options) {\n        var response, login;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (options.idToken) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                throw new Error('The verifyIdToken method requires an ID Token');\n\n              case 2:\n                _context11.next = 4;\n                return this.getFederatedSignonCertsAsync();\n\n              case 4:\n                response = _context11.sent;\n                _context11.next = 7;\n                return this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n\n              case 7:\n                login = _context11.sent;\n                return _context11.abrupt(\"return\", login);\n\n              case 9:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function verifyIdTokenAsync(_x7) {\n        return _verifyIdTokenAsync.apply(this, arguments);\n      }\n\n      return verifyIdTokenAsync;\n    }()\n    /**\r\n     * Obtains information about the provisioned access token.  Especially useful\r\n     * if you want to check the scopes that were provisioned to a given token.\r\n     *\r\n     * @param accessToken Required.  The Access Token for which you want to get\r\n     * user info.\r\n     */\n\n  }, {\n    key: \"getTokenInfo\",\n    value: function () {\n      var _getTokenInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(accessToken) {\n        var _yield$this$transport, data, info;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.transporter.request({\n                  method: 'POST',\n                  headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                    Authorization: \"Bearer \".concat(accessToken)\n                  },\n                  url: OAuth2Client.GOOGLE_TOKEN_INFO_URL\n                });\n\n              case 2:\n                _yield$this$transport = _context12.sent;\n                data = _yield$this$transport.data;\n                info = Object.assign({\n                  expiry_date: new Date().getTime() + data.expires_in * 1000,\n                  scopes: data.scope.split(' ')\n                }, data);\n                delete info.expires_in;\n                delete info.scope;\n                return _context12.abrupt(\"return\", info);\n\n              case 8:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getTokenInfo(_x8) {\n        return _getTokenInfo.apply(this, arguments);\n      }\n\n      return getTokenInfo;\n    }()\n  }, {\n    key: \"getFederatedSignonCerts\",\n    value: function getFederatedSignonCerts(callback) {\n      if (callback) {\n        this.getFederatedSignonCertsAsync().then(function (r) {\n          return callback(null, r.certs, r.res);\n        }, callback);\n      } else {\n        return this.getFederatedSignonCertsAsync();\n      }\n    }\n  }, {\n    key: \"getFederatedSignonCertsAsync\",\n    value: function () {\n      var _getFederatedSignonCertsAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var nowTime, format, res, url, cacheControl, cacheAge, pattern, regexResult, certificates, _iterator, _step, key, now;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                nowTime = new Date().getTime();\n                format = crypto_1.hasBrowserCrypto() ? CertificateFormat.JWK : CertificateFormat.PEM;\n\n                if (!(this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format)) {\n                  _context13.next = 4;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", {\n                  certs: this.certificateCache,\n                  format: format\n                });\n\n              case 4:\n                _context13.t0 = format;\n                _context13.next = _context13.t0 === CertificateFormat.PEM ? 7 : _context13.t0 === CertificateFormat.JWK ? 9 : 11;\n                break;\n\n              case 7:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n                return _context13.abrupt(\"break\", 12);\n\n              case 9:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n                return _context13.abrupt(\"break\", 12);\n\n              case 11:\n                throw new Error(\"Unsupported certificate format \".concat(format));\n\n              case 12:\n                _context13.prev = 12;\n                _context13.next = 15;\n                return this.transporter.request({\n                  url: url\n                });\n\n              case 15:\n                res = _context13.sent;\n                _context13.next = 22;\n                break;\n\n              case 18:\n                _context13.prev = 18;\n                _context13.t1 = _context13[\"catch\"](12);\n                _context13.t1.message = \"Failed to retrieve verification certificates: \".concat(_context13.t1.message);\n                throw _context13.t1;\n\n              case 22:\n                cacheControl = res ? res.headers['cache-control'] : undefined;\n                cacheAge = -1;\n\n                if (cacheControl) {\n                  pattern = new RegExp('max-age=([0-9]*)');\n                  regexResult = pattern.exec(cacheControl);\n\n                  if (regexResult && regexResult.length === 2) {\n                    // Cache results with max-age (in seconds)\n                    cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n                  }\n                }\n\n                certificates = {};\n                _context13.t2 = format;\n                _context13.next = _context13.t2 === CertificateFormat.PEM ? 29 : _context13.t2 === CertificateFormat.JWK ? 31 : 34;\n                break;\n\n              case 29:\n                certificates = res.data;\n                return _context13.abrupt(\"break\", 35);\n\n              case 31:\n                _iterator = _createForOfIteratorHelper(res.data.keys);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    key = _step.value;\n                    certificates[key.kid] = key;\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                return _context13.abrupt(\"break\", 35);\n\n              case 34:\n                throw new Error(\"Unsupported certificate format \".concat(format));\n\n              case 35:\n                now = new Date();\n                this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n                this.certificateCache = certificates;\n                this.certificateCacheFormat = format;\n                return _context13.abrupt(\"return\", {\n                  certs: certificates,\n                  format: format,\n                  res: res\n                });\n\n              case 40:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[12, 18]]);\n      }));\n\n      function getFederatedSignonCertsAsync() {\n        return _getFederatedSignonCertsAsync.apply(this, arguments);\n      }\n\n      return getFederatedSignonCertsAsync;\n    }()\n  }, {\n    key: \"getIapPublicKeys\",\n    value: function getIapPublicKeys(callback) {\n      if (callback) {\n        this.getIapPublicKeysAsync().then(function (r) {\n          return callback(null, r.pubkeys, r.res);\n        }, callback);\n      } else {\n        return this.getIapPublicKeysAsync();\n      }\n    }\n  }, {\n    key: \"getIapPublicKeysAsync\",\n    value: function () {\n      var _getIapPublicKeysAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var res, url;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n                _context14.prev = 1;\n                _context14.next = 4;\n                return this.transporter.request({\n                  url: url\n                });\n\n              case 4:\n                res = _context14.sent;\n                _context14.next = 11;\n                break;\n\n              case 7:\n                _context14.prev = 7;\n                _context14.t0 = _context14[\"catch\"](1);\n                _context14.t0.message = \"Failed to retrieve verification certificates: \".concat(_context14.t0.message);\n                throw _context14.t0;\n\n              case 11:\n                return _context14.abrupt(\"return\", {\n                  pubkeys: res.data,\n                  res: res\n                });\n\n              case 12:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this, [[1, 7]]);\n      }));\n\n      function getIapPublicKeysAsync() {\n        return _getIapPublicKeysAsync.apply(this, arguments);\n      }\n\n      return getIapPublicKeysAsync;\n    }()\n  }, {\n    key: \"verifySignedJwtWithCerts\",\n    value: function verifySignedJwtWithCerts() {\n      // To make the code compatible with browser SubtleCrypto we need to make\n      // this method async.\n      throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\r\n     * Verify the id token is signed with the correct certificate\r\n     * and is from the correct audience.\r\n     * @param jwt The jwt to verify (The ID Token in this case).\r\n     * @param certs The array of certs to test the jwt against.\r\n     * @param requiredAudience The audience to test the jwt against.\r\n     * @param issuers The allowed issuers of the jwt (Optional).\r\n     * @param maxExpiry The max expiry the certificate can be (Optional).\r\n     * @return Returns a promise resolving to LoginTicket on verification.\r\n     */\n\n  }, {\n    key: \"verifySignedJwtWithCertsAsync\",\n    value: function () {\n      var _verifySignedJwtWithCertsAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        var crypto, segments, signed, signature, envelope, payload, cert, verified, iat, exp, now, earliest, latest, aud, audVerified;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                crypto = crypto_1.createCrypto();\n\n                if (!maxExpiry) {\n                  maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n                }\n\n                segments = jwt.split('.');\n\n                if (!(segments.length !== 3)) {\n                  _context15.next = 5;\n                  break;\n                }\n\n                throw new Error('Wrong number of segments in token: ' + jwt);\n\n              case 5:\n                signed = segments[0] + '.' + segments[1];\n                signature = segments[2];\n                _context15.prev = 7;\n                envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n                _context15.next = 15;\n                break;\n\n              case 11:\n                _context15.prev = 11;\n                _context15.t0 = _context15[\"catch\"](7);\n                _context15.t0.message = \"Can't parse token envelope: \".concat(segments[0], \"': \").concat(_context15.t0.message);\n                throw _context15.t0;\n\n              case 15:\n                if (envelope) {\n                  _context15.next = 17;\n                  break;\n                }\n\n                throw new Error(\"Can't parse token envelope: \" + segments[0]);\n\n              case 17:\n                _context15.prev = 17;\n                payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n                _context15.next = 25;\n                break;\n\n              case 21:\n                _context15.prev = 21;\n                _context15.t1 = _context15[\"catch\"](17);\n                _context15.t1.message = \"Can't parse token payload '\".concat(segments[0]);\n                throw _context15.t1;\n\n              case 25:\n                if (payload) {\n                  _context15.next = 27;\n                  break;\n                }\n\n                throw new Error(\"Can't parse token payload: \" + segments[1]);\n\n              case 27:\n                if (Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n                  _context15.next = 29;\n                  break;\n                }\n\n                throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n\n              case 29:\n                cert = certs[envelope.kid];\n\n                if (envelope.alg === 'ES256') {\n                  signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n                }\n\n                _context15.next = 33;\n                return crypto.verify(cert, signed, signature);\n\n              case 33:\n                verified = _context15.sent;\n\n                if (verified) {\n                  _context15.next = 36;\n                  break;\n                }\n\n                throw new Error('Invalid token signature: ' + jwt);\n\n              case 36:\n                if (payload.iat) {\n                  _context15.next = 38;\n                  break;\n                }\n\n                throw new Error('No issue time in token: ' + JSON.stringify(payload));\n\n              case 38:\n                if (payload.exp) {\n                  _context15.next = 40;\n                  break;\n                }\n\n                throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n\n              case 40:\n                iat = Number(payload.iat);\n\n                if (!isNaN(iat)) {\n                  _context15.next = 43;\n                  break;\n                }\n\n                throw new Error('iat field using invalid format');\n\n              case 43:\n                exp = Number(payload.exp);\n\n                if (!isNaN(exp)) {\n                  _context15.next = 46;\n                  break;\n                }\n\n                throw new Error('exp field using invalid format');\n\n              case 46:\n                now = new Date().getTime() / 1000;\n\n                if (!(exp >= now + maxExpiry)) {\n                  _context15.next = 49;\n                  break;\n                }\n\n                throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n\n              case 49:\n                earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n                latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n                if (!(now < earliest)) {\n                  _context15.next = 53;\n                  break;\n                }\n\n                throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n\n              case 53:\n                if (!(now > latest)) {\n                  _context15.next = 55;\n                  break;\n                }\n\n                throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n\n              case 55:\n                if (!(issuers && issuers.indexOf(payload.iss) < 0)) {\n                  _context15.next = 57;\n                  break;\n                }\n\n                throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n\n              case 57:\n                if (!(typeof requiredAudience !== 'undefined' && requiredAudience !== null)) {\n                  _context15.next = 63;\n                  break;\n                }\n\n                aud = payload.aud;\n                audVerified = false; // If the requiredAudience is an array, check if it contains token\n                // audience\n\n                if (requiredAudience.constructor === Array) {\n                  audVerified = requiredAudience.indexOf(aud) > -1;\n                } else {\n                  audVerified = aud === requiredAudience;\n                }\n\n                if (audVerified) {\n                  _context15.next = 63;\n                  break;\n                }\n\n                throw new Error('Wrong recipient, payload audience != requiredAudience');\n\n              case 63:\n                return _context15.abrupt(\"return\", new loginticket_1.LoginTicket(envelope, payload));\n\n              case 64:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, null, [[7, 11], [17, 21]]);\n      }));\n\n      function verifySignedJwtWithCertsAsync(_x9, _x10, _x11, _x12, _x13) {\n        return _verifySignedJwtWithCertsAsync.apply(this, arguments);\n      }\n\n      return verifySignedJwtWithCertsAsync;\n    }()\n    /**\r\n     * Returns a promise that resolves with AccessTokenResponse type if\r\n     * refreshHandler is defined.\r\n     * If not, nothing is returned.\r\n     */\n\n  }, {\n    key: \"processAndValidateRefreshHandler\",\n    value: function () {\n      var _processAndValidateRefreshHandler = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        var accessTokenResponse;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (!this.refreshHandler) {\n                  _context16.next = 7;\n                  break;\n                }\n\n                _context16.next = 3;\n                return this.refreshHandler();\n\n              case 3:\n                accessTokenResponse = _context16.sent;\n\n                if (accessTokenResponse.access_token) {\n                  _context16.next = 6;\n                  break;\n                }\n\n                throw new Error('No access token is returned by the refreshHandler callback.');\n\n              case 6:\n                return _context16.abrupt(\"return\", accessTokenResponse);\n\n              case 7:\n                return _context16.abrupt(\"return\");\n\n              case 8:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function processAndValidateRefreshHandler() {\n        return _processAndValidateRefreshHandler.apply(this, arguments);\n      }\n\n      return processAndValidateRefreshHandler;\n    }()\n    /**\r\n     * Returns true if a token is expired or will expire within\r\n     * eagerRefreshThresholdMillismilliseconds.\r\n     * If there is no expiry time, assumes the token is not expired or expiring.\r\n     */\n\n  }, {\n    key: \"isTokenExpiring\",\n    value: function isTokenExpiring() {\n      var expiryDate = this.credentials.expiry_date;\n      return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n    }\n  }], [{\n    key: \"getRevokeTokenUrl\",\n    value: function getRevokeTokenUrl(token) {\n      var parameters = querystring.stringify({\n        token: token\n      });\n      return \"\".concat(OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_, \"?\").concat(parameters);\n    }\n  }]);\n\n  return OAuth2Client;\n}(authclient_1.AuthClient);\n\nexports.OAuth2Client = OAuth2Client;\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\r\n * The base URL for auth endpoints.\r\n */\n\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\r\n * The base endpoint for token retrieval.\r\n */\n\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\r\n * The base endpoint to revoke tokens.\r\n */\n\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\r\n * Google Sign on certificates in PEM format.\r\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\r\n * Google Sign on certificates in JWK format.\r\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\r\n * Google Sign on certificates in JWK format.\r\n */\n\nOAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n/**\r\n * Clock skew - five minutes in seconds\r\n */\n\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\r\n * Max Token Lifetime is one day in seconds\r\n */\n\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\r\n * The allowed oauth token issuers.\r\n */\n\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];","map":{"version":3,"sources":["C:/Users/Enrique Niebles/Documents/Misin TIC 2021/Ciclo 3 - Desarrollo Software/Heroku/client/react/node_modules/google-auth-library/build/src/auth/oauth2client.js"],"names":["Object","defineProperty","exports","value","OAuth2Client","CertificateFormat","CodeChallengeMethod","querystring","require","stream","formatEcdsa","crypto_1","authclient_1","loginticket_1","optionsOrClientId","clientSecret","redirectUri","certificateCache","certificateExpiry","certificateCacheFormat","PEM","refreshTokenPromises","Map","opts","clientId","_clientId","_clientSecret","eagerRefreshThresholdMillis","forceRefreshOnFailure","code_challenge_method","code_challenge","Error","response_type","client_id","redirect_uri","scope","Array","join","rootUrl","GOOGLE_OAUTH2_AUTH_BASE_URL_","stringify","crypto","createCrypto","randomString","randomBytesBase64","codeVerifier","replace","sha256DigestBase64","unencodedCodeChallenge","codeChallenge","split","codeOrOptions","callback","options","code","getTokenAsync","then","r","tokens","res","e","response","url","GOOGLE_OAUTH2_TOKEN_URL_","values","client_secret","grant_type","code_verifier","transporter","request","method","data","headers","expires_in","expiry_date","Date","getTime","emit","refreshToken","refreshTokenNoCache","has","get","p","delete","set","refresh_token","refreshAccessTokenAsync","credentials","getAccessTokenAsync","token","shouldRefresh","access_token","isTokenExpiring","refreshHandler","processAndValidateRefreshHandler","refreshedAccessToken","setCredentials","getRequestMetadataAsync","thisCreds","apiKey","token_type","Authorization","addSharedMetadataHeaders","status","message","getRevokeTokenUrl","revokeCredentialsAsync","revokeToken","requestAsync","retry","r2","statusCode","mayRequireRefresh","mayRequireRefreshWithNoRefreshToken","isReadableStream","config","Readable","isAuthErr","verifyIdTokenAsync","idToken","getFederatedSignonCertsAsync","verifySignedJwtWithCertsAsync","certs","audience","ISSUERS_","maxExpiry","login","accessToken","GOOGLE_TOKEN_INFO_URL","info","assign","scopes","nowTime","format","hasBrowserCrypto","JWK","GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_","GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_","cacheControl","undefined","cacheAge","pattern","RegExp","regexResult","exec","length","Number","certificates","keys","key","kid","now","getIapPublicKeysAsync","pubkeys","GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_","jwt","requiredAudience","issuers","MAX_TOKEN_LIFETIME_SECS_","segments","signed","signature","envelope","JSON","parse","decodeBase64StringUtf8","payload","prototype","hasOwnProperty","call","cert","alg","joseToDer","toString","verify","verified","iat","exp","isNaN","earliest","CLOCK_SKEW_SECS_","latest","indexOf","iss","aud","audVerified","constructor","LoginTicket","accessTokenResponse","expiryDate","parameters","GOOGLE_OAUTH2_REVOKE_URL_","AuthClient"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Copyright 2019 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\r\nconst querystring = require(\"querystring\");\r\nconst stream = require(\"stream\");\r\nconst formatEcdsa = require(\"ecdsa-sig-formatter\");\r\nconst crypto_1 = require(\"../crypto/crypto\");\r\nconst authclient_1 = require(\"./authclient\");\r\nconst loginticket_1 = require(\"./loginticket\");\r\nvar CodeChallengeMethod;\r\n(function (CodeChallengeMethod) {\r\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\r\n    CodeChallengeMethod[\"S256\"] = \"S256\";\r\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\r\nvar CertificateFormat;\r\n(function (CertificateFormat) {\r\n    CertificateFormat[\"PEM\"] = \"PEM\";\r\n    CertificateFormat[\"JWK\"] = \"JWK\";\r\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\r\nclass OAuth2Client extends authclient_1.AuthClient {\r\n    constructor(optionsOrClientId, clientSecret, redirectUri) {\r\n        super();\r\n        this.certificateCache = {};\r\n        this.certificateExpiry = null;\r\n        this.certificateCacheFormat = CertificateFormat.PEM;\r\n        this.refreshTokenPromises = new Map();\r\n        const opts = optionsOrClientId && typeof optionsOrClientId === 'object'\r\n            ? optionsOrClientId\r\n            : { clientId: optionsOrClientId, clientSecret, redirectUri };\r\n        this._clientId = opts.clientId;\r\n        this._clientSecret = opts.clientSecret;\r\n        this.redirectUri = opts.redirectUri;\r\n        this.eagerRefreshThresholdMillis =\r\n            opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\r\n        this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\r\n    }\r\n    /**\r\n     * Generates URL for consent page landing.\r\n     * @param opts Options.\r\n     * @return URL to consent page.\r\n     */\r\n    generateAuthUrl(opts = {}) {\r\n        if (opts.code_challenge_method && !opts.code_challenge) {\r\n            throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\r\n        }\r\n        opts.response_type = opts.response_type || 'code';\r\n        opts.client_id = opts.client_id || this._clientId;\r\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\r\n        // Allow scopes to be passed either as array or a string\r\n        if (opts.scope instanceof Array) {\r\n            opts.scope = opts.scope.join(' ');\r\n        }\r\n        const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\r\n        return (rootUrl +\r\n            '?' +\r\n            querystring.stringify(opts));\r\n    }\r\n    generateCodeVerifier() {\r\n        // To make the code compatible with browser SubtleCrypto we need to make\r\n        // this method async.\r\n        throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\r\n    }\r\n    /**\r\n     * Convenience method to automatically generate a code_verifier, and its\r\n     * resulting SHA256. If used, this must be paired with a S256\r\n     * code_challenge_method.\r\n     *\r\n     * For a full example see:\r\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\r\n     */\r\n    async generateCodeVerifierAsync() {\r\n        // base64 encoding uses 6 bits per character, and we want to generate128\r\n        // characters. 6*128/8 = 96.\r\n        const crypto = crypto_1.createCrypto();\r\n        const randomString = crypto.randomBytesBase64(96);\r\n        // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\r\n        // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\r\n        // swapping out a few chars.\r\n        const codeVerifier = randomString\r\n            .replace(/\\+/g, '~')\r\n            .replace(/=/g, '_')\r\n            .replace(/\\//g, '-');\r\n        // Generate the base64 encoded SHA256\r\n        const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\r\n        // We need to use base64UrlEncoding instead of standard base64\r\n        const codeChallenge = unencodedCodeChallenge\r\n            .split('=')[0]\r\n            .replace(/\\+/g, '-')\r\n            .replace(/\\//g, '_');\r\n        return { codeVerifier, codeChallenge };\r\n    }\r\n    getToken(codeOrOptions, callback) {\r\n        const options = typeof codeOrOptions === 'string' ? { code: codeOrOptions } : codeOrOptions;\r\n        if (callback) {\r\n            this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\r\n        }\r\n        else {\r\n            return this.getTokenAsync(options);\r\n        }\r\n    }\r\n    async getTokenAsync(options) {\r\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\r\n        const values = {\r\n            code: options.code,\r\n            client_id: options.client_id || this._clientId,\r\n            client_secret: this._clientSecret,\r\n            redirect_uri: options.redirect_uri || this.redirectUri,\r\n            grant_type: 'authorization_code',\r\n            code_verifier: options.codeVerifier,\r\n        };\r\n        const res = await this.transporter.request({\r\n            method: 'POST',\r\n            url,\r\n            data: querystring.stringify(values),\r\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\r\n        });\r\n        const tokens = res.data;\r\n        if (res.data && res.data.expires_in) {\r\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\r\n            delete tokens.expires_in;\r\n        }\r\n        this.emit('tokens', tokens);\r\n        return { tokens, res };\r\n    }\r\n    /**\r\n     * Refreshes the access token.\r\n     * @param refresh_token Existing refresh token.\r\n     * @private\r\n     */\r\n    async refreshToken(refreshToken) {\r\n        if (!refreshToken) {\r\n            return this.refreshTokenNoCache(refreshToken);\r\n        }\r\n        // If a request to refresh using the same token has started,\r\n        // return the same promise.\r\n        if (this.refreshTokenPromises.has(refreshToken)) {\r\n            return this.refreshTokenPromises.get(refreshToken);\r\n        }\r\n        const p = this.refreshTokenNoCache(refreshToken).then(r => {\r\n            this.refreshTokenPromises.delete(refreshToken);\r\n            return r;\r\n        }, e => {\r\n            this.refreshTokenPromises.delete(refreshToken);\r\n            throw e;\r\n        });\r\n        this.refreshTokenPromises.set(refreshToken, p);\r\n        return p;\r\n    }\r\n    async refreshTokenNoCache(refreshToken) {\r\n        if (!refreshToken) {\r\n            throw new Error('No refresh token is set.');\r\n        }\r\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\r\n        const data = {\r\n            refresh_token: refreshToken,\r\n            client_id: this._clientId,\r\n            client_secret: this._clientSecret,\r\n            grant_type: 'refresh_token',\r\n        };\r\n        // request for new token\r\n        const res = await this.transporter.request({\r\n            method: 'POST',\r\n            url,\r\n            data: querystring.stringify(data),\r\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\r\n        });\r\n        const tokens = res.data;\r\n        // TODO: de-duplicate this code from a few spots\r\n        if (res.data && res.data.expires_in) {\r\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\r\n            delete tokens.expires_in;\r\n        }\r\n        this.emit('tokens', tokens);\r\n        return { tokens, res };\r\n    }\r\n    refreshAccessToken(callback) {\r\n        if (callback) {\r\n            this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\r\n        }\r\n        else {\r\n            return this.refreshAccessTokenAsync();\r\n        }\r\n    }\r\n    async refreshAccessTokenAsync() {\r\n        const r = await this.refreshToken(this.credentials.refresh_token);\r\n        const tokens = r.tokens;\r\n        tokens.refresh_token = this.credentials.refresh_token;\r\n        this.credentials = tokens;\r\n        return { credentials: this.credentials, res: r.res };\r\n    }\r\n    getAccessToken(callback) {\r\n        if (callback) {\r\n            this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\r\n        }\r\n        else {\r\n            return this.getAccessTokenAsync();\r\n        }\r\n    }\r\n    async getAccessTokenAsync() {\r\n        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\r\n        if (shouldRefresh) {\r\n            if (!this.credentials.refresh_token) {\r\n                if (this.refreshHandler) {\r\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\r\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\r\n                        this.setCredentials(refreshedAccessToken);\r\n                        return { token: this.credentials.access_token };\r\n                    }\r\n                }\r\n                else {\r\n                    throw new Error('No refresh token or refresh handler callback is set.');\r\n                }\r\n            }\r\n            const r = await this.refreshAccessTokenAsync();\r\n            if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\r\n                throw new Error('Could not refresh access token.');\r\n            }\r\n            return { token: r.credentials.access_token, res: r.res };\r\n        }\r\n        else {\r\n            return { token: this.credentials.access_token };\r\n        }\r\n    }\r\n    /**\r\n     * The main authentication interface.  It takes an optional url which when\r\n     * present is the endpoint being accessed, and returns a Promise which\r\n     * resolves with authorization header fields.\r\n     *\r\n     * In OAuth2Client, the result has the form:\r\n     * { Authorization: 'Bearer <access_token_value>' }\r\n     * @param url The optional url being authorized\r\n     */\r\n    async getRequestHeaders(url) {\r\n        const headers = (await this.getRequestMetadataAsync(url)).headers;\r\n        return headers;\r\n    }\r\n    async getRequestMetadataAsync(\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    url) {\r\n        const thisCreds = this.credentials;\r\n        if (!thisCreds.access_token &&\r\n            !thisCreds.refresh_token &&\r\n            !this.apiKey &&\r\n            !this.refreshHandler) {\r\n            throw new Error('No access, refresh token, API key or refresh handler callback is set.');\r\n        }\r\n        if (thisCreds.access_token && !this.isTokenExpiring()) {\r\n            thisCreds.token_type = thisCreds.token_type || 'Bearer';\r\n            const headers = {\r\n                Authorization: thisCreds.token_type + ' ' + thisCreds.access_token,\r\n            };\r\n            return { headers: this.addSharedMetadataHeaders(headers) };\r\n        }\r\n        // If refreshHandler exists, call processAndValidateRefreshHandler().\r\n        if (this.refreshHandler) {\r\n            const refreshedAccessToken = await this.processAndValidateRefreshHandler();\r\n            if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\r\n                this.setCredentials(refreshedAccessToken);\r\n                const headers = {\r\n                    Authorization: 'Bearer ' + this.credentials.access_token,\r\n                };\r\n                return { headers: this.addSharedMetadataHeaders(headers) };\r\n            }\r\n        }\r\n        if (this.apiKey) {\r\n            return { headers: { 'X-Goog-Api-Key': this.apiKey } };\r\n        }\r\n        let r = null;\r\n        let tokens = null;\r\n        try {\r\n            r = await this.refreshToken(thisCreds.refresh_token);\r\n            tokens = r.tokens;\r\n        }\r\n        catch (err) {\r\n            const e = err;\r\n            if (e.response &&\r\n                (e.response.status === 403 || e.response.status === 404)) {\r\n                e.message = `Could not refresh access token: ${e.message}`;\r\n            }\r\n            throw e;\r\n        }\r\n        const credentials = this.credentials;\r\n        credentials.token_type = credentials.token_type || 'Bearer';\r\n        tokens.refresh_token = credentials.refresh_token;\r\n        this.credentials = tokens;\r\n        const headers = {\r\n            Authorization: credentials.token_type + ' ' + tokens.access_token,\r\n        };\r\n        return { headers: this.addSharedMetadataHeaders(headers), res: r.res };\r\n    }\r\n    /**\r\n     * Generates an URL to revoke the given token.\r\n     * @param token The existing token to be revoked.\r\n     */\r\n    static getRevokeTokenUrl(token) {\r\n        const parameters = querystring.stringify({ token });\r\n        return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\r\n    }\r\n    revokeToken(token, callback) {\r\n        const opts = {\r\n            url: OAuth2Client.getRevokeTokenUrl(token),\r\n            method: 'POST',\r\n        };\r\n        if (callback) {\r\n            this.transporter\r\n                .request(opts)\r\n                .then(r => callback(null, r), callback);\r\n        }\r\n        else {\r\n            return this.transporter.request(opts);\r\n        }\r\n    }\r\n    revokeCredentials(callback) {\r\n        if (callback) {\r\n            this.revokeCredentialsAsync().then(res => callback(null, res), callback);\r\n        }\r\n        else {\r\n            return this.revokeCredentialsAsync();\r\n        }\r\n    }\r\n    async revokeCredentialsAsync() {\r\n        const token = this.credentials.access_token;\r\n        this.credentials = {};\r\n        if (token) {\r\n            return this.revokeToken(token);\r\n        }\r\n        else {\r\n            throw new Error('No access token to revoke.');\r\n        }\r\n    }\r\n    request(opts, callback) {\r\n        if (callback) {\r\n            this.requestAsync(opts).then(r => callback(null, r), e => {\r\n                return callback(e, e.response);\r\n            });\r\n        }\r\n        else {\r\n            return this.requestAsync(opts);\r\n        }\r\n    }\r\n    async requestAsync(opts, retry = false) {\r\n        let r2;\r\n        try {\r\n            const r = await this.getRequestMetadataAsync(opts.url);\r\n            opts.headers = opts.headers || {};\r\n            if (r.headers && r.headers['x-goog-user-project']) {\r\n                opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\r\n            }\r\n            if (r.headers && r.headers.Authorization) {\r\n                opts.headers.Authorization = r.headers.Authorization;\r\n            }\r\n            if (this.apiKey) {\r\n                opts.headers['X-Goog-Api-Key'] = this.apiKey;\r\n            }\r\n            r2 = await this.transporter.request(opts);\r\n        }\r\n        catch (e) {\r\n            const res = e.response;\r\n            if (res) {\r\n                const statusCode = res.status;\r\n                // Retry the request for metadata if the following criteria are true:\r\n                // - We haven't already retried.  It only makes sense to retry once.\r\n                // - The response was a 401 or a 403\r\n                // - The request didn't send a readableStream\r\n                // - An access_token and refresh_token were available, but either no\r\n                //   expiry_date was available or the forceRefreshOnFailure flag is set.\r\n                //   The absent expiry_date case can happen when developers stash the\r\n                //   access_token and refresh_token for later use, but the access_token\r\n                //   fails on the first try because it's expired. Some developers may\r\n                //   choose to enable forceRefreshOnFailure to mitigate time-related\r\n                //   errors.\r\n                // Or the following criteria are true:\r\n                // - We haven't already retried.  It only makes sense to retry once.\r\n                // - The response was a 401 or a 403\r\n                // - The request didn't send a readableStream\r\n                // - No refresh_token was available\r\n                // - An access_token and a refreshHandler callback were available, but\r\n                //   either no expiry_date was available or the forceRefreshOnFailure\r\n                //   flag is set. The access_token fails on the first try because it's\r\n                //   expired. Some developers may choose to enable forceRefreshOnFailure\r\n                //   to mitigate time-related errors.\r\n                const mayRequireRefresh = this.credentials &&\r\n                    this.credentials.access_token &&\r\n                    this.credentials.refresh_token &&\r\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure);\r\n                const mayRequireRefreshWithNoRefreshToken = this.credentials &&\r\n                    this.credentials.access_token &&\r\n                    !this.credentials.refresh_token &&\r\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure) &&\r\n                    this.refreshHandler;\r\n                const isReadableStream = res.config.data instanceof stream.Readable;\r\n                const isAuthErr = statusCode === 401 || statusCode === 403;\r\n                if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\r\n                    await this.refreshAccessTokenAsync();\r\n                    return this.requestAsync(opts, true);\r\n                }\r\n                else if (!retry &&\r\n                    isAuthErr &&\r\n                    !isReadableStream &&\r\n                    mayRequireRefreshWithNoRefreshToken) {\r\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\r\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\r\n                        this.setCredentials(refreshedAccessToken);\r\n                    }\r\n                    return this.requestAsync(opts, true);\r\n                }\r\n            }\r\n            throw e;\r\n        }\r\n        return r2;\r\n    }\r\n    verifyIdToken(options, callback) {\r\n        // This function used to accept two arguments instead of an options object.\r\n        // Check the types to help users upgrade with less pain.\r\n        // This check can be removed after a 2.0 release.\r\n        if (callback && typeof callback !== 'function') {\r\n            throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\r\n        }\r\n        if (callback) {\r\n            this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\r\n        }\r\n        else {\r\n            return this.verifyIdTokenAsync(options);\r\n        }\r\n    }\r\n    async verifyIdTokenAsync(options) {\r\n        if (!options.idToken) {\r\n            throw new Error('The verifyIdToken method requires an ID Token');\r\n        }\r\n        const response = await this.getFederatedSignonCertsAsync();\r\n        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\r\n        return login;\r\n    }\r\n    /**\r\n     * Obtains information about the provisioned access token.  Especially useful\r\n     * if you want to check the scopes that were provisioned to a given token.\r\n     *\r\n     * @param accessToken Required.  The Access Token for which you want to get\r\n     * user info.\r\n     */\r\n    async getTokenInfo(accessToken) {\r\n        const { data } = await this.transporter.request({\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/x-www-form-urlencoded',\r\n                Authorization: `Bearer ${accessToken}`,\r\n            },\r\n            url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\r\n        });\r\n        const info = Object.assign({\r\n            expiry_date: new Date().getTime() + data.expires_in * 1000,\r\n            scopes: data.scope.split(' '),\r\n        }, data);\r\n        delete info.expires_in;\r\n        delete info.scope;\r\n        return info;\r\n    }\r\n    getFederatedSignonCerts(callback) {\r\n        if (callback) {\r\n            this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\r\n        }\r\n        else {\r\n            return this.getFederatedSignonCertsAsync();\r\n        }\r\n    }\r\n    async getFederatedSignonCertsAsync() {\r\n        const nowTime = new Date().getTime();\r\n        const format = crypto_1.hasBrowserCrypto()\r\n            ? CertificateFormat.JWK\r\n            : CertificateFormat.PEM;\r\n        if (this.certificateExpiry &&\r\n            nowTime < this.certificateExpiry.getTime() &&\r\n            this.certificateCacheFormat === format) {\r\n            return { certs: this.certificateCache, format };\r\n        }\r\n        let res;\r\n        let url;\r\n        switch (format) {\r\n            case CertificateFormat.PEM:\r\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\r\n                break;\r\n            case CertificateFormat.JWK:\r\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\r\n                break;\r\n            default:\r\n                throw new Error(`Unsupported certificate format ${format}`);\r\n        }\r\n        try {\r\n            res = await this.transporter.request({ url });\r\n        }\r\n        catch (e) {\r\n            e.message = `Failed to retrieve verification certificates: ${e.message}`;\r\n            throw e;\r\n        }\r\n        const cacheControl = res ? res.headers['cache-control'] : undefined;\r\n        let cacheAge = -1;\r\n        if (cacheControl) {\r\n            const pattern = new RegExp('max-age=([0-9]*)');\r\n            const regexResult = pattern.exec(cacheControl);\r\n            if (regexResult && regexResult.length === 2) {\r\n                // Cache results with max-age (in seconds)\r\n                cacheAge = Number(regexResult[1]) * 1000; // milliseconds\r\n            }\r\n        }\r\n        let certificates = {};\r\n        switch (format) {\r\n            case CertificateFormat.PEM:\r\n                certificates = res.data;\r\n                break;\r\n            case CertificateFormat.JWK:\r\n                for (const key of res.data.keys) {\r\n                    certificates[key.kid] = key;\r\n                }\r\n                break;\r\n            default:\r\n                throw new Error(`Unsupported certificate format ${format}`);\r\n        }\r\n        const now = new Date();\r\n        this.certificateExpiry =\r\n            cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\r\n        this.certificateCache = certificates;\r\n        this.certificateCacheFormat = format;\r\n        return { certs: certificates, format, res };\r\n    }\r\n    getIapPublicKeys(callback) {\r\n        if (callback) {\r\n            this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\r\n        }\r\n        else {\r\n            return this.getIapPublicKeysAsync();\r\n        }\r\n    }\r\n    async getIapPublicKeysAsync() {\r\n        let res;\r\n        const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\r\n        try {\r\n            res = await this.transporter.request({ url });\r\n        }\r\n        catch (e) {\r\n            e.message = `Failed to retrieve verification certificates: ${e.message}`;\r\n            throw e;\r\n        }\r\n        return { pubkeys: res.data, res };\r\n    }\r\n    verifySignedJwtWithCerts() {\r\n        // To make the code compatible with browser SubtleCrypto we need to make\r\n        // this method async.\r\n        throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\r\n    }\r\n    /**\r\n     * Verify the id token is signed with the correct certificate\r\n     * and is from the correct audience.\r\n     * @param jwt The jwt to verify (The ID Token in this case).\r\n     * @param certs The array of certs to test the jwt against.\r\n     * @param requiredAudience The audience to test the jwt against.\r\n     * @param issuers The allowed issuers of the jwt (Optional).\r\n     * @param maxExpiry The max expiry the certificate can be (Optional).\r\n     * @return Returns a promise resolving to LoginTicket on verification.\r\n     */\r\n    async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\r\n        const crypto = crypto_1.createCrypto();\r\n        if (!maxExpiry) {\r\n            maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\r\n        }\r\n        const segments = jwt.split('.');\r\n        if (segments.length !== 3) {\r\n            throw new Error('Wrong number of segments in token: ' + jwt);\r\n        }\r\n        const signed = segments[0] + '.' + segments[1];\r\n        let signature = segments[2];\r\n        let envelope;\r\n        let payload;\r\n        try {\r\n            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\r\n        }\r\n        catch (err) {\r\n            err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\r\n            throw err;\r\n        }\r\n        if (!envelope) {\r\n            throw new Error(\"Can't parse token envelope: \" + segments[0]);\r\n        }\r\n        try {\r\n            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\r\n        }\r\n        catch (err) {\r\n            err.message = `Can't parse token payload '${segments[0]}`;\r\n            throw err;\r\n        }\r\n        if (!payload) {\r\n            throw new Error(\"Can't parse token payload: \" + segments[1]);\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\r\n            // If this is not present, then there's no reason to attempt verification\r\n            throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\r\n        }\r\n        const cert = certs[envelope.kid];\r\n        if (envelope.alg === 'ES256') {\r\n            signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\r\n        }\r\n        const verified = await crypto.verify(cert, signed, signature);\r\n        if (!verified) {\r\n            throw new Error('Invalid token signature: ' + jwt);\r\n        }\r\n        if (!payload.iat) {\r\n            throw new Error('No issue time in token: ' + JSON.stringify(payload));\r\n        }\r\n        if (!payload.exp) {\r\n            throw new Error('No expiration time in token: ' + JSON.stringify(payload));\r\n        }\r\n        const iat = Number(payload.iat);\r\n        if (isNaN(iat))\r\n            throw new Error('iat field using invalid format');\r\n        const exp = Number(payload.exp);\r\n        if (isNaN(exp))\r\n            throw new Error('exp field using invalid format');\r\n        const now = new Date().getTime() / 1000;\r\n        if (exp >= now + maxExpiry) {\r\n            throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\r\n        }\r\n        const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\r\n        const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\r\n        if (now < earliest) {\r\n            throw new Error('Token used too early, ' +\r\n                now +\r\n                ' < ' +\r\n                earliest +\r\n                ': ' +\r\n                JSON.stringify(payload));\r\n        }\r\n        if (now > latest) {\r\n            throw new Error('Token used too late, ' +\r\n                now +\r\n                ' > ' +\r\n                latest +\r\n                ': ' +\r\n                JSON.stringify(payload));\r\n        }\r\n        if (issuers && issuers.indexOf(payload.iss) < 0) {\r\n            throw new Error('Invalid issuer, expected one of [' +\r\n                issuers +\r\n                '], but got ' +\r\n                payload.iss);\r\n        }\r\n        // Check the audience matches if we have one\r\n        if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\r\n            const aud = payload.aud;\r\n            let audVerified = false;\r\n            // If the requiredAudience is an array, check if it contains token\r\n            // audience\r\n            if (requiredAudience.constructor === Array) {\r\n                audVerified = requiredAudience.indexOf(aud) > -1;\r\n            }\r\n            else {\r\n                audVerified = aud === requiredAudience;\r\n            }\r\n            if (!audVerified) {\r\n                throw new Error('Wrong recipient, payload audience != requiredAudience');\r\n            }\r\n        }\r\n        return new loginticket_1.LoginTicket(envelope, payload);\r\n    }\r\n    /**\r\n     * Returns a promise that resolves with AccessTokenResponse type if\r\n     * refreshHandler is defined.\r\n     * If not, nothing is returned.\r\n     */\r\n    async processAndValidateRefreshHandler() {\r\n        if (this.refreshHandler) {\r\n            const accessTokenResponse = await this.refreshHandler();\r\n            if (!accessTokenResponse.access_token) {\r\n                throw new Error('No access token is returned by the refreshHandler callback.');\r\n            }\r\n            return accessTokenResponse;\r\n        }\r\n        return;\r\n    }\r\n    /**\r\n     * Returns true if a token is expired or will expire within\r\n     * eagerRefreshThresholdMillismilliseconds.\r\n     * If there is no expiry time, assumes the token is not expired or expiring.\r\n     */\r\n    isTokenExpiring() {\r\n        const expiryDate = this.credentials.expiry_date;\r\n        return expiryDate\r\n            ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis\r\n            : false;\r\n    }\r\n}\r\nexports.OAuth2Client = OAuth2Client;\r\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\r\n/**\r\n * The base URL for auth endpoints.\r\n */\r\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\r\n/**\r\n * The base endpoint for token retrieval.\r\n */\r\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\r\n/**\r\n * The base endpoint to revoke tokens.\r\n */\r\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\r\n/**\r\n * Google Sign on certificates in PEM format.\r\n */\r\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\r\n/**\r\n * Google Sign on certificates in JWK format.\r\n */\r\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\r\n/**\r\n * Google Sign on certificates in JWK format.\r\n */\r\nOAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\r\n/**\r\n * Clock skew - five minutes in seconds\r\n */\r\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\r\n/**\r\n * Max Token Lifetime is one day in seconds\r\n */\r\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\r\n/**\r\n * The allowed oauth token issuers.\r\n */\r\nOAuth2Client.ISSUERS_ = [\r\n    'accounts.google.com',\r\n    'https://accounts.google.com',\r\n];\r\n//# sourceMappingURL=oauth2client.js.map"]},"metadata":{},"sourceType":"script"}