{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\n\nconst stream = require(\"stream\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst sts = require(\"./stscredentials\");\n/**\r\n * The required token exchange grant_type: rfc8693#section-2.1\r\n */\n\n\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\r\n * The requested token exchange requested_token_type: rfc8693#section-2.1\r\n */\n\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\n\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/** The google apis domain pattern. */\n\nconst GOOGLE_APIS_DOMAIN_PATTERN = '\\\\.googleapis\\\\.com$';\n/** The variable portion pattern in a Google APIs domain. */\n\nconst VARIABLE_PORTION_PATTERN = '[^\\\\.\\\\s\\\\/\\\\\\\\]+';\n/**\r\n * Offset to take into account network delays and server clock skews.\r\n */\n\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\r\n * The credentials JSON file type for external account clients.\r\n * There are 3 types of JSON configs:\r\n * 1. authorized_user => Google end user credential\r\n * 2. service_account => Google service account credential\r\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\r\n */\n\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/** Cloud resource manager URL used to retrieve project information. */\n\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/** The workforce audience pattern. */\n\nconst WORKFORCE_AUDIENCE_PATTERN = '//iam.googleapis.com/locations/[^/]+/workforcePools/[^/]+/providers/.+';\n/**\r\n * Base external account client. This is used to instantiate AuthClients for\r\n * exchanging external account credentials for GCP access token and authorizing\r\n * requests to GCP APIs.\r\n * The base class implements common logic for exchanging various type of\r\n * external credentials for GCP access token. The logic of determining and\r\n * retrieving the external credential based on the environment and\r\n * credential_source will be left for the subclasses.\r\n */\n\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n  /**\r\n   * Instantiate a BaseExternalAccountClient instance using the provided JSON\r\n   * object loaded from an external account credentials file.\r\n   * @param options The external account options object typically loaded\r\n   *   from the external account JSON credential file.\r\n   * @param additionalOptions Optional additional behavior customization\r\n   *   options. These currently customize expiration threshold time and\r\n   *   whether to retry on 401/403 API request errors.\r\n   */\n  constructor(options, additionalOptions) {\n    super();\n\n    if (options.type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n      throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` + `received \"${options.type}\"`);\n    }\n\n    this.clientAuth = options.client_id ? {\n      confidentialClientType: 'basic',\n      clientId: options.client_id,\n      clientSecret: options.client_secret\n    } : undefined;\n\n    if (!this.validateGoogleAPIsUrl('sts', options.token_url)) {\n      throw new Error(`\"${options.token_url}\" is not a valid token url.`);\n    }\n\n    this.stsCredential = new sts.StsCredentials(options.token_url, this.clientAuth); // Default OAuth scope. This could be overridden via public property.\n\n    this.scopes = [DEFAULT_OAUTH_SCOPE];\n    this.cachedAccessToken = null;\n    this.audience = options.audience;\n    this.subjectTokenType = options.subject_token_type;\n    this.quotaProjectId = options.quota_project_id;\n    this.workforcePoolUserProject = options.workforce_pool_user_project;\n    const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n\n    if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {\n      throw new Error('workforcePoolUserProject should not be set for non-workforce pool ' + 'credentials.');\n    }\n\n    if (typeof options.service_account_impersonation_url !== 'undefined' && !this.validateGoogleAPIsUrl('iamcredentials', options.service_account_impersonation_url)) {\n      throw new Error(`\"${options.service_account_impersonation_url}\" is ` + 'not a valid service account impersonation url.');\n    }\n\n    this.serviceAccountImpersonationUrl = options.service_account_impersonation_url; // As threshold could be zero,\n    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n    // zero value.\n\n    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n      this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n    } else {\n      this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n    }\n\n    this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    this.projectId = null;\n    this.projectNumber = this.getProjectNumber(this.audience);\n  }\n  /** The service account email to be impersonated, if available. */\n\n\n  getServiceAccountEmail() {\n    var _a;\n\n    if (this.serviceAccountImpersonationUrl) {\n      // Parse email from URL. The formal looks as follows:\n      // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n      const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n      const result = re.exec(this.serviceAccountImpersonationUrl);\n      return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\n    }\n\n    return null;\n  }\n  /**\r\n   * Provides a mechanism to inject GCP access tokens directly.\r\n   * When the provided credential expires, a new credential, using the\r\n   * external account options, is retrieved.\r\n   * @param credentials The Credentials object to set on the current client.\r\n   */\n\n\n  setCredentials(credentials) {\n    super.setCredentials(credentials);\n    this.cachedAccessToken = credentials;\n  }\n  /**\r\n   * @return A promise that resolves with the current GCP access token\r\n   *   response. If the current credential is expired, a new one is retrieved.\r\n   */\n\n\n  async getAccessToken() {\n    // If cached access token is unavailable or expired, force refresh.\n    if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n      await this.refreshAccessTokenAsync();\n    } // Return GCP access token in GetAccessTokenResponse format.\n\n\n    return {\n      token: this.cachedAccessToken.access_token,\n      res: this.cachedAccessToken.res\n    };\n  }\n  /**\r\n   * The main authentication interface. It takes an optional url which when\r\n   * present is the endpoint being accessed, and returns a Promise which\r\n   * resolves with authorization header fields.\r\n   *\r\n   * The result has the form:\r\n   * { Authorization: 'Bearer <access_token_value>' }\r\n   */\n\n\n  async getRequestHeaders() {\n    const accessTokenResponse = await this.getAccessToken();\n    const headers = {\n      Authorization: `Bearer ${accessTokenResponse.token}`\n    };\n    return this.addSharedMetadataHeaders(headers);\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\r\n   * @return A promise that resolves with the project ID corresponding to the\r\n   *   current workload identity pool or current workforce pool if\r\n   *   determinable. For workforce pool credential, it returns the project ID\r\n   *   corresponding to the workforcePoolUserProject.\r\n   *   This is introduced to match the current pattern of using the Auth\r\n   *   library:\r\n   *   const projectId = await auth.getProjectId();\r\n   *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\r\n   *   const res = await client.request({ url });\r\n   *   The resource may not have permission\r\n   *   (resourcemanager.projects.get) to call this API or the required\r\n   *   scopes may not be selected:\r\n   *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\r\n   */\n\n\n  async getProjectId() {\n    const projectNumber = this.projectNumber || this.workforcePoolUserProject;\n\n    if (this.projectId) {\n      // Return previously determined project ID.\n      return this.projectId;\n    } else if (projectNumber) {\n      // Preferable not to use request() to avoid retrial policies.\n      const headers = await this.getRequestHeaders();\n      const response = await this.transporter.request({\n        headers,\n        url: `${exports.CLOUD_RESOURCE_MANAGER}${projectNumber}`,\n        responseType: 'json'\n      });\n      this.projectId = response.data.projectId;\n      return this.projectId;\n    }\n\n    return null;\n  }\n  /**\r\n   * Authenticates the provided HTTP request, processes it and resolves with the\r\n   * returned response.\r\n   * @param opts The HTTP request options.\r\n   * @param retry Whether the current attempt is a retry after a failed attempt.\r\n   * @return A promise that resolves with the successful response.\r\n   */\n\n\n  async requestAsync(opts, retry = false) {\n    let response;\n\n    try {\n      const requestHeaders = await this.getRequestHeaders();\n      opts.headers = opts.headers || {};\n\n      if (requestHeaders && requestHeaders['x-goog-user-project']) {\n        opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n      }\n\n      if (requestHeaders && requestHeaders.Authorization) {\n        opts.headers.Authorization = requestHeaders.Authorization;\n      }\n\n      response = await this.transporter.request(opts);\n    } catch (e) {\n      const res = e.response;\n\n      if (res) {\n        const statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - forceRefreshOnFailure is true\n\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n\n        if (!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n          await this.refreshAccessTokenAsync();\n          return await this.requestAsync(opts, true);\n        }\n      }\n\n      throw e;\n    }\n\n    return response;\n  }\n  /**\r\n   * Forces token refresh, even if unexpired tokens are currently cached.\r\n   * External credentials are exchanged for GCP access tokens via the token\r\n   * exchange endpoint and other settings provided in the client options\r\n   * object.\r\n   * If the service_account_impersonation_url is provided, an additional\r\n   * step to exchange the external account GCP access token for a service\r\n   * account impersonated token is performed.\r\n   * @return A promise that resolves with the fresh GCP access tokens.\r\n   */\n\n\n  async refreshAccessTokenAsync() {\n    // Retrieve the external credential.\n    const subjectToken = await this.retrieveSubjectToken(); // Construct the STS credentials options.\n\n    const stsCredentialsOptions = {\n      grantType: STS_GRANT_TYPE,\n      audience: this.audience,\n      requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n      subjectToken,\n      subjectTokenType: this.subjectTokenType,\n      // generateAccessToken requires the provided access token to have\n      // scopes:\n      // https://www.googleapis.com/auth/iam or\n      // https://www.googleapis.com/auth/cloud-platform\n      // The new service account access token scopes will match the user\n      // provided ones.\n      scope: this.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : this.getScopesArray()\n    }; // Exchange the external credentials for a GCP access token.\n    // Client auth is prioritized over passing the workforcePoolUserProject\n    // parameter for STS token exchange.\n\n    const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? {\n      userProject: this.workforcePoolUserProject\n    } : undefined;\n    const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, additionalOptions);\n\n    if (this.serviceAccountImpersonationUrl) {\n      this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n    } else if (stsResponse.expires_in) {\n      // Save response in cached access token.\n      this.cachedAccessToken = {\n        access_token: stsResponse.access_token,\n        expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n        res: stsResponse.res\n      };\n    } else {\n      // Save response in cached access token.\n      this.cachedAccessToken = {\n        access_token: stsResponse.access_token,\n        res: stsResponse.res\n      };\n    } // Save credentials.\n\n\n    this.credentials = {};\n    Object.assign(this.credentials, this.cachedAccessToken);\n    delete this.credentials.res; // Trigger tokens event to notify external listeners.\n\n    this.emit('tokens', {\n      refresh_token: null,\n      expiry_date: this.cachedAccessToken.expiry_date,\n      access_token: this.cachedAccessToken.access_token,\n      token_type: 'Bearer',\n      id_token: null\n    }); // Return the cached access token.\n\n    return this.cachedAccessToken;\n  }\n  /**\r\n   * Returns the workload identity pool project number if it is determinable\r\n   * from the audience resource name.\r\n   * @param audience The STS audience used to determine the project number.\r\n   * @return The project number associated with the workload identity pool, if\r\n   *   this can be determined from the STS audience field. Otherwise, null is\r\n   *   returned.\r\n   */\n\n\n  getProjectNumber(audience) {\n    // STS audience pattern:\n    // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n    const match = audience.match(/\\/projects\\/([^/]+)/);\n\n    if (!match) {\n      return null;\n    }\n\n    return match[1];\n  }\n  /**\r\n   * Exchanges an external account GCP access token for a service\r\n   * account impersonated access token using iamcredentials\r\n   * GenerateAccessToken API.\r\n   * @param token The access token to exchange for a service account access\r\n   *   token.\r\n   * @return A promise that resolves with the service account impersonated\r\n   *   credentials response.\r\n   */\n\n\n  async getImpersonatedAccessToken(token) {\n    const opts = {\n      url: this.serviceAccountImpersonationUrl,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${token}`\n      },\n      data: {\n        scope: this.getScopesArray()\n      },\n      responseType: 'json'\n    };\n    const response = await this.transporter.request(opts);\n    const successResponse = response.data;\n    return {\n      access_token: successResponse.accessToken,\n      // Convert from ISO format to timestamp.\n      expiry_date: new Date(successResponse.expireTime).getTime(),\n      res: response\n    };\n  }\n  /**\r\n   * Returns whether the provided credentials are expired or not.\r\n   * If there is no expiry time, assumes the token is not expired or expiring.\r\n   * @param accessToken The credentials to check for expiration.\r\n   * @return Whether the credentials are expired or not.\r\n   */\n\n\n  isExpired(accessToken) {\n    const now = new Date().getTime();\n    return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n  /**\r\n   * @return The list of scopes for the requested GCP access token.\r\n   */\n\n\n  getScopesArray() {\n    // Since scopes can be provided as string or array, the type should\n    // be normalized.\n    if (typeof this.scopes === 'string') {\n      return [this.scopes];\n    } else if (typeof this.scopes === 'undefined') {\n      return [DEFAULT_OAUTH_SCOPE];\n    } else {\n      return this.scopes;\n    }\n  }\n  /**\r\n   * Checks whether Google APIs URL is valid.\r\n   * @param apiName The apiName of url.\r\n   * @param url The Google API URL to validate.\r\n   * @return Whether the URL is valid or not.\r\n   */\n\n\n  validateGoogleAPIsUrl(apiName, url) {\n    let parsedUrl; // Return false if error is thrown during parsing URL.\n\n    try {\n      parsedUrl = new URL(url);\n    } catch (e) {\n      return false;\n    }\n\n    const urlDomain = parsedUrl.hostname; // Check the protocol is https.\n\n    if (parsedUrl.protocol !== 'https:') {\n      return false;\n    }\n\n    const googleAPIsDomainPatterns = [new RegExp('^' + VARIABLE_PORTION_PATTERN + '\\\\.' + apiName + GOOGLE_APIS_DOMAIN_PATTERN), new RegExp('^' + apiName + GOOGLE_APIS_DOMAIN_PATTERN), new RegExp('^' + apiName + '\\\\.' + VARIABLE_PORTION_PATTERN + GOOGLE_APIS_DOMAIN_PATTERN), new RegExp('^' + VARIABLE_PORTION_PATTERN + '\\\\-' + apiName + GOOGLE_APIS_DOMAIN_PATTERN)];\n\n    for (const googleAPIsDomainPattern of googleAPIsDomainPatterns) {\n      if (urlDomain.match(googleAPIsDomainPattern)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nexports.BaseExternalAccountClient = BaseExternalAccountClient;","map":{"version":3,"sources":["C:/Users/Enrique Niebles/Documents/MisiÃ³n TIC 2021/Ciclo 3 - Desarrollo Software/Despliegue/grupo4/react/node_modules/google-auth-library/build/src/auth/baseexternalclient.js"],"names":["Object","defineProperty","exports","value","BaseExternalAccountClient","CLOUD_RESOURCE_MANAGER","EXTERNAL_ACCOUNT_TYPE","EXPIRATION_TIME_OFFSET","stream","require","authclient_1","sts","STS_GRANT_TYPE","STS_REQUEST_TOKEN_TYPE","DEFAULT_OAUTH_SCOPE","GOOGLE_APIS_DOMAIN_PATTERN","VARIABLE_PORTION_PATTERN","WORKFORCE_AUDIENCE_PATTERN","AuthClient","constructor","options","additionalOptions","type","Error","clientAuth","client_id","confidentialClientType","clientId","clientSecret","client_secret","undefined","validateGoogleAPIsUrl","token_url","stsCredential","StsCredentials","scopes","cachedAccessToken","audience","subjectTokenType","subject_token_type","quotaProjectId","quota_project_id","workforcePoolUserProject","workforce_pool_user_project","workforceAudiencePattern","RegExp","match","service_account_impersonation_url","serviceAccountImpersonationUrl","eagerRefreshThresholdMillis","forceRefreshOnFailure","projectId","projectNumber","getProjectNumber","getServiceAccountEmail","_a","re","result","exec","groups","email","setCredentials","credentials","getAccessToken","isExpired","refreshAccessTokenAsync","token","access_token","res","getRequestHeaders","accessTokenResponse","headers","Authorization","addSharedMetadataHeaders","request","opts","callback","requestAsync","then","r","e","response","getProjectId","transporter","url","responseType","data","retry","requestHeaders","statusCode","status","isReadableStream","config","Readable","isAuthErr","subjectToken","retrieveSubjectToken","stsCredentialsOptions","grantType","requestedTokenType","scope","getScopesArray","userProject","stsResponse","exchangeToken","getImpersonatedAccessToken","expires_in","expiry_date","Date","getTime","assign","emit","refresh_token","token_type","id_token","method","successResponse","accessToken","expireTime","now","apiName","parsedUrl","URL","urlDomain","hostname","protocol","googleAPIsDomainPatterns","googleAPIsDomainPattern"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Copyright 2021 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\r\nconst stream = require(\"stream\");\r\nconst authclient_1 = require(\"./authclient\");\r\nconst sts = require(\"./stscredentials\");\r\n/**\r\n * The required token exchange grant_type: rfc8693#section-2.1\r\n */\r\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\r\n/**\r\n * The requested token exchange requested_token_type: rfc8693#section-2.1\r\n */\r\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\r\n/** The default OAuth scope to request when none is provided. */\r\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\r\n/** The google apis domain pattern. */\r\nconst GOOGLE_APIS_DOMAIN_PATTERN = '\\\\.googleapis\\\\.com$';\r\n/** The variable portion pattern in a Google APIs domain. */\r\nconst VARIABLE_PORTION_PATTERN = '[^\\\\.\\\\s\\\\/\\\\\\\\]+';\r\n/**\r\n * Offset to take into account network delays and server clock skews.\r\n */\r\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\r\n/**\r\n * The credentials JSON file type for external account clients.\r\n * There are 3 types of JSON configs:\r\n * 1. authorized_user => Google end user credential\r\n * 2. service_account => Google service account credential\r\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\r\n */\r\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\r\n/** Cloud resource manager URL used to retrieve project information. */\r\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\r\n/** The workforce audience pattern. */\r\nconst WORKFORCE_AUDIENCE_PATTERN = '//iam.googleapis.com/locations/[^/]+/workforcePools/[^/]+/providers/.+';\r\n/**\r\n * Base external account client. This is used to instantiate AuthClients for\r\n * exchanging external account credentials for GCP access token and authorizing\r\n * requests to GCP APIs.\r\n * The base class implements common logic for exchanging various type of\r\n * external credentials for GCP access token. The logic of determining and\r\n * retrieving the external credential based on the environment and\r\n * credential_source will be left for the subclasses.\r\n */\r\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\r\n    /**\r\n     * Instantiate a BaseExternalAccountClient instance using the provided JSON\r\n     * object loaded from an external account credentials file.\r\n     * @param options The external account options object typically loaded\r\n     *   from the external account JSON credential file.\r\n     * @param additionalOptions Optional additional behavior customization\r\n     *   options. These currently customize expiration threshold time and\r\n     *   whether to retry on 401/403 API request errors.\r\n     */\r\n    constructor(options, additionalOptions) {\r\n        super();\r\n        if (options.type !== exports.EXTERNAL_ACCOUNT_TYPE) {\r\n            throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` +\r\n                `received \"${options.type}\"`);\r\n        }\r\n        this.clientAuth = options.client_id\r\n            ? {\r\n                confidentialClientType: 'basic',\r\n                clientId: options.client_id,\r\n                clientSecret: options.client_secret,\r\n            }\r\n            : undefined;\r\n        if (!this.validateGoogleAPIsUrl('sts', options.token_url)) {\r\n            throw new Error(`\"${options.token_url}\" is not a valid token url.`);\r\n        }\r\n        this.stsCredential = new sts.StsCredentials(options.token_url, this.clientAuth);\r\n        // Default OAuth scope. This could be overridden via public property.\r\n        this.scopes = [DEFAULT_OAUTH_SCOPE];\r\n        this.cachedAccessToken = null;\r\n        this.audience = options.audience;\r\n        this.subjectTokenType = options.subject_token_type;\r\n        this.quotaProjectId = options.quota_project_id;\r\n        this.workforcePoolUserProject = options.workforce_pool_user_project;\r\n        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\r\n        if (this.workforcePoolUserProject &&\r\n            !this.audience.match(workforceAudiencePattern)) {\r\n            throw new Error('workforcePoolUserProject should not be set for non-workforce pool ' +\r\n                'credentials.');\r\n        }\r\n        if (typeof options.service_account_impersonation_url !== 'undefined' &&\r\n            !this.validateGoogleAPIsUrl('iamcredentials', options.service_account_impersonation_url)) {\r\n            throw new Error(`\"${options.service_account_impersonation_url}\" is ` +\r\n                'not a valid service account impersonation url.');\r\n        }\r\n        this.serviceAccountImpersonationUrl =\r\n            options.service_account_impersonation_url;\r\n        // As threshold could be zero,\r\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\r\n        // zero value.\r\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\r\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\r\n        }\r\n        else {\r\n            this.eagerRefreshThresholdMillis = additionalOptions\r\n                .eagerRefreshThresholdMillis;\r\n        }\r\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\r\n        this.projectId = null;\r\n        this.projectNumber = this.getProjectNumber(this.audience);\r\n    }\r\n    /** The service account email to be impersonated, if available. */\r\n    getServiceAccountEmail() {\r\n        var _a;\r\n        if (this.serviceAccountImpersonationUrl) {\r\n            // Parse email from URL. The formal looks as follows:\r\n            // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\r\n            const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\r\n            const result = re.exec(this.serviceAccountImpersonationUrl);\r\n            return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Provides a mechanism to inject GCP access tokens directly.\r\n     * When the provided credential expires, a new credential, using the\r\n     * external account options, is retrieved.\r\n     * @param credentials The Credentials object to set on the current client.\r\n     */\r\n    setCredentials(credentials) {\r\n        super.setCredentials(credentials);\r\n        this.cachedAccessToken = credentials;\r\n    }\r\n    /**\r\n     * @return A promise that resolves with the current GCP access token\r\n     *   response. If the current credential is expired, a new one is retrieved.\r\n     */\r\n    async getAccessToken() {\r\n        // If cached access token is unavailable or expired, force refresh.\r\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\r\n            await this.refreshAccessTokenAsync();\r\n        }\r\n        // Return GCP access token in GetAccessTokenResponse format.\r\n        return {\r\n            token: this.cachedAccessToken.access_token,\r\n            res: this.cachedAccessToken.res,\r\n        };\r\n    }\r\n    /**\r\n     * The main authentication interface. It takes an optional url which when\r\n     * present is the endpoint being accessed, and returns a Promise which\r\n     * resolves with authorization header fields.\r\n     *\r\n     * The result has the form:\r\n     * { Authorization: 'Bearer <access_token_value>' }\r\n     */\r\n    async getRequestHeaders() {\r\n        const accessTokenResponse = await this.getAccessToken();\r\n        const headers = {\r\n            Authorization: `Bearer ${accessTokenResponse.token}`,\r\n        };\r\n        return this.addSharedMetadataHeaders(headers);\r\n    }\r\n    request(opts, callback) {\r\n        if (callback) {\r\n            this.requestAsync(opts).then(r => callback(null, r), e => {\r\n                return callback(e, e.response);\r\n            });\r\n        }\r\n        else {\r\n            return this.requestAsync(opts);\r\n        }\r\n    }\r\n    /**\r\n     * @return A promise that resolves with the project ID corresponding to the\r\n     *   current workload identity pool or current workforce pool if\r\n     *   determinable. For workforce pool credential, it returns the project ID\r\n     *   corresponding to the workforcePoolUserProject.\r\n     *   This is introduced to match the current pattern of using the Auth\r\n     *   library:\r\n     *   const projectId = await auth.getProjectId();\r\n     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\r\n     *   const res = await client.request({ url });\r\n     *   The resource may not have permission\r\n     *   (resourcemanager.projects.get) to call this API or the required\r\n     *   scopes may not be selected:\r\n     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\r\n     */\r\n    async getProjectId() {\r\n        const projectNumber = this.projectNumber || this.workforcePoolUserProject;\r\n        if (this.projectId) {\r\n            // Return previously determined project ID.\r\n            return this.projectId;\r\n        }\r\n        else if (projectNumber) {\r\n            // Preferable not to use request() to avoid retrial policies.\r\n            const headers = await this.getRequestHeaders();\r\n            const response = await this.transporter.request({\r\n                headers,\r\n                url: `${exports.CLOUD_RESOURCE_MANAGER}${projectNumber}`,\r\n                responseType: 'json',\r\n            });\r\n            this.projectId = response.data.projectId;\r\n            return this.projectId;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Authenticates the provided HTTP request, processes it and resolves with the\r\n     * returned response.\r\n     * @param opts The HTTP request options.\r\n     * @param retry Whether the current attempt is a retry after a failed attempt.\r\n     * @return A promise that resolves with the successful response.\r\n     */\r\n    async requestAsync(opts, retry = false) {\r\n        let response;\r\n        try {\r\n            const requestHeaders = await this.getRequestHeaders();\r\n            opts.headers = opts.headers || {};\r\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\r\n                opts.headers['x-goog-user-project'] =\r\n                    requestHeaders['x-goog-user-project'];\r\n            }\r\n            if (requestHeaders && requestHeaders.Authorization) {\r\n                opts.headers.Authorization = requestHeaders.Authorization;\r\n            }\r\n            response = await this.transporter.request(opts);\r\n        }\r\n        catch (e) {\r\n            const res = e.response;\r\n            if (res) {\r\n                const statusCode = res.status;\r\n                // Retry the request for metadata if the following criteria are true:\r\n                // - We haven't already retried.  It only makes sense to retry once.\r\n                // - The response was a 401 or a 403\r\n                // - The request didn't send a readableStream\r\n                // - forceRefreshOnFailure is true\r\n                const isReadableStream = res.config.data instanceof stream.Readable;\r\n                const isAuthErr = statusCode === 401 || statusCode === 403;\r\n                if (!retry &&\r\n                    isAuthErr &&\r\n                    !isReadableStream &&\r\n                    this.forceRefreshOnFailure) {\r\n                    await this.refreshAccessTokenAsync();\r\n                    return await this.requestAsync(opts, true);\r\n                }\r\n            }\r\n            throw e;\r\n        }\r\n        return response;\r\n    }\r\n    /**\r\n     * Forces token refresh, even if unexpired tokens are currently cached.\r\n     * External credentials are exchanged for GCP access tokens via the token\r\n     * exchange endpoint and other settings provided in the client options\r\n     * object.\r\n     * If the service_account_impersonation_url is provided, an additional\r\n     * step to exchange the external account GCP access token for a service\r\n     * account impersonated token is performed.\r\n     * @return A promise that resolves with the fresh GCP access tokens.\r\n     */\r\n    async refreshAccessTokenAsync() {\r\n        // Retrieve the external credential.\r\n        const subjectToken = await this.retrieveSubjectToken();\r\n        // Construct the STS credentials options.\r\n        const stsCredentialsOptions = {\r\n            grantType: STS_GRANT_TYPE,\r\n            audience: this.audience,\r\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\r\n            subjectToken,\r\n            subjectTokenType: this.subjectTokenType,\r\n            // generateAccessToken requires the provided access token to have\r\n            // scopes:\r\n            // https://www.googleapis.com/auth/iam or\r\n            // https://www.googleapis.com/auth/cloud-platform\r\n            // The new service account access token scopes will match the user\r\n            // provided ones.\r\n            scope: this.serviceAccountImpersonationUrl\r\n                ? [DEFAULT_OAUTH_SCOPE]\r\n                : this.getScopesArray(),\r\n        };\r\n        // Exchange the external credentials for a GCP access token.\r\n        // Client auth is prioritized over passing the workforcePoolUserProject\r\n        // parameter for STS token exchange.\r\n        const additionalOptions = !this.clientAuth && this.workforcePoolUserProject\r\n            ? { userProject: this.workforcePoolUserProject }\r\n            : undefined;\r\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, additionalOptions);\r\n        if (this.serviceAccountImpersonationUrl) {\r\n            this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\r\n        }\r\n        else if (stsResponse.expires_in) {\r\n            // Save response in cached access token.\r\n            this.cachedAccessToken = {\r\n                access_token: stsResponse.access_token,\r\n                expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\r\n                res: stsResponse.res,\r\n            };\r\n        }\r\n        else {\r\n            // Save response in cached access token.\r\n            this.cachedAccessToken = {\r\n                access_token: stsResponse.access_token,\r\n                res: stsResponse.res,\r\n            };\r\n        }\r\n        // Save credentials.\r\n        this.credentials = {};\r\n        Object.assign(this.credentials, this.cachedAccessToken);\r\n        delete this.credentials.res;\r\n        // Trigger tokens event to notify external listeners.\r\n        this.emit('tokens', {\r\n            refresh_token: null,\r\n            expiry_date: this.cachedAccessToken.expiry_date,\r\n            access_token: this.cachedAccessToken.access_token,\r\n            token_type: 'Bearer',\r\n            id_token: null,\r\n        });\r\n        // Return the cached access token.\r\n        return this.cachedAccessToken;\r\n    }\r\n    /**\r\n     * Returns the workload identity pool project number if it is determinable\r\n     * from the audience resource name.\r\n     * @param audience The STS audience used to determine the project number.\r\n     * @return The project number associated with the workload identity pool, if\r\n     *   this can be determined from the STS audience field. Otherwise, null is\r\n     *   returned.\r\n     */\r\n    getProjectNumber(audience) {\r\n        // STS audience pattern:\r\n        // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\r\n        const match = audience.match(/\\/projects\\/([^/]+)/);\r\n        if (!match) {\r\n            return null;\r\n        }\r\n        return match[1];\r\n    }\r\n    /**\r\n     * Exchanges an external account GCP access token for a service\r\n     * account impersonated access token using iamcredentials\r\n     * GenerateAccessToken API.\r\n     * @param token The access token to exchange for a service account access\r\n     *   token.\r\n     * @return A promise that resolves with the service account impersonated\r\n     *   credentials response.\r\n     */\r\n    async getImpersonatedAccessToken(token) {\r\n        const opts = {\r\n            url: this.serviceAccountImpersonationUrl,\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                Authorization: `Bearer ${token}`,\r\n            },\r\n            data: {\r\n                scope: this.getScopesArray(),\r\n            },\r\n            responseType: 'json',\r\n        };\r\n        const response = await this.transporter.request(opts);\r\n        const successResponse = response.data;\r\n        return {\r\n            access_token: successResponse.accessToken,\r\n            // Convert from ISO format to timestamp.\r\n            expiry_date: new Date(successResponse.expireTime).getTime(),\r\n            res: response,\r\n        };\r\n    }\r\n    /**\r\n     * Returns whether the provided credentials are expired or not.\r\n     * If there is no expiry time, assumes the token is not expired or expiring.\r\n     * @param accessToken The credentials to check for expiration.\r\n     * @return Whether the credentials are expired or not.\r\n     */\r\n    isExpired(accessToken) {\r\n        const now = new Date().getTime();\r\n        return accessToken.expiry_date\r\n            ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis\r\n            : false;\r\n    }\r\n    /**\r\n     * @return The list of scopes for the requested GCP access token.\r\n     */\r\n    getScopesArray() {\r\n        // Since scopes can be provided as string or array, the type should\r\n        // be normalized.\r\n        if (typeof this.scopes === 'string') {\r\n            return [this.scopes];\r\n        }\r\n        else if (typeof this.scopes === 'undefined') {\r\n            return [DEFAULT_OAUTH_SCOPE];\r\n        }\r\n        else {\r\n            return this.scopes;\r\n        }\r\n    }\r\n    /**\r\n     * Checks whether Google APIs URL is valid.\r\n     * @param apiName The apiName of url.\r\n     * @param url The Google API URL to validate.\r\n     * @return Whether the URL is valid or not.\r\n     */\r\n    validateGoogleAPIsUrl(apiName, url) {\r\n        let parsedUrl;\r\n        // Return false if error is thrown during parsing URL.\r\n        try {\r\n            parsedUrl = new URL(url);\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n        const urlDomain = parsedUrl.hostname;\r\n        // Check the protocol is https.\r\n        if (parsedUrl.protocol !== 'https:') {\r\n            return false;\r\n        }\r\n        const googleAPIsDomainPatterns = [\r\n            new RegExp('^' +\r\n                VARIABLE_PORTION_PATTERN +\r\n                '\\\\.' +\r\n                apiName +\r\n                GOOGLE_APIS_DOMAIN_PATTERN),\r\n            new RegExp('^' + apiName + GOOGLE_APIS_DOMAIN_PATTERN),\r\n            new RegExp('^' +\r\n                apiName +\r\n                '\\\\.' +\r\n                VARIABLE_PORTION_PATTERN +\r\n                GOOGLE_APIS_DOMAIN_PATTERN),\r\n            new RegExp('^' +\r\n                VARIABLE_PORTION_PATTERN +\r\n                '\\\\-' +\r\n                apiName +\r\n                GOOGLE_APIS_DOMAIN_PATTERN),\r\n        ];\r\n        for (const googleAPIsDomainPattern of googleAPIsDomainPatterns) {\r\n            if (urlDomain.match(googleAPIsDomainPattern)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.BaseExternalAccountClient = BaseExternalAccountClient;\r\n//# sourceMappingURL=baseexternalclient.js.map"]},"metadata":{},"sourceType":"script"}