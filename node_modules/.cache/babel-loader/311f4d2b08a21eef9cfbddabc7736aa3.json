{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\n\nconst stream = require(\"stream\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst sts = require(\"./stscredentials\");\n/**\r\n * The required token exchange grant_type: rfc8693#section-2.1\r\n */\n\n\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\r\n * The requested token exchange requested_token_type: rfc8693#section-2.1\r\n */\n\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\r\n * The requested token exchange subject_token_type: rfc8693#section-2.1\r\n */\n\nconst STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The STS access token exchange end point. */\n\nconst STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1/token';\n/**\r\n * The maximum number of access boundary rules a Credential Access Boundary\r\n * can contain.\r\n */\n\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\r\n * Offset to take into account network delays and server clock skews.\r\n */\n\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\r\n * Defines a set of Google credentials that are downscoped from an existing set\r\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\r\n * Access Management (IAM) permissions that a short-lived credential can use.\r\n * The common pattern of usage is to have a token broker with elevated access\r\n * generate these downscoped credentials from higher access source credentials\r\n * and pass the downscoped short-lived access tokens to a token consumer via\r\n * some secure authenticated channel for limited access to Google Cloud Storage\r\n * resources.\r\n */\n\nclass DownscopedClient extends authclient_1.AuthClient {\n  /**\r\n   * Instantiates a downscoped client object using the provided source\r\n   * AuthClient and credential access boundary rules.\r\n   * To downscope permissions of a source AuthClient, a Credential Access\r\n   * Boundary that specifies which resources the new credential can access, as\r\n   * well as an upper bound on the permissions that are available on each\r\n   * resource, has to be defined. A downscoped client can then be instantiated\r\n   * using the source AuthClient and the Credential Access Boundary.\r\n   * @param authClient The source AuthClient to be downscoped based on the\r\n   *   provided Credential Access Boundary rules.\r\n   * @param credentialAccessBoundary The Credential Access Boundary which\r\n   *   contains a list of access boundary rules. Each rule contains information\r\n   *   on the resource that the rule applies to, the upper bound of the\r\n   *   permissions that are available on that resource and an optional\r\n   *   condition to further restrict permissions.\r\n   * @param additionalOptions Optional additional behavior customization\r\n   *   options. These currently customize expiration threshold time and\r\n   *   whether to retry on 401/403 API request errors.\r\n   * @param quotaProjectId Optional quota project id for setting up in the\r\n   *   x-goog-user-project header.\r\n   */\n  constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {\n    super();\n    this.authClient = authClient;\n    this.credentialAccessBoundary = credentialAccessBoundary; // Check 1-10 Access Boundary Rules are defined within Credential Access\n    // Boundary.\n\n    if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n      throw new Error('At least one access boundary rule needs to be defined.');\n    } else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n      throw new Error('The provided access boundary has more than ' + `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\n    } // Check at least one permission should be defined in each Access Boundary\n    // Rule.\n\n\n    for (const rule of credentialAccessBoundary.accessBoundary.accessBoundaryRules) {\n      if (rule.availablePermissions.length === 0) {\n        throw new Error('At least one permission should be defined in access boundary rules.');\n      }\n    }\n\n    this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\n    this.cachedDownscopedAccessToken = null; // As threshold could be zero,\n    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n    // zero value.\n\n    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n      this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n    } else {\n      this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n    }\n\n    this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    this.quotaProjectId = quotaProjectId;\n  }\n  /**\r\n   * Provides a mechanism to inject Downscoped access tokens directly.\r\n   * The expiry_date field is required to facilitate determination of the token\r\n   * expiration which would make it easier for the token consumer to handle.\r\n   * @param credentials The Credentials object to set on the current client.\r\n   */\n\n\n  setCredentials(credentials) {\n    if (!credentials.expiry_date) {\n      throw new Error('The access token expiry_date field is missing in the provided ' + 'credentials.');\n    }\n\n    super.setCredentials(credentials);\n    this.cachedDownscopedAccessToken = credentials;\n  }\n\n  async getAccessToken() {\n    // If the cached access token is unavailable or expired, force refresh.\n    // The Downscoped access token will be returned in\n    // DownscopedAccessTokenResponse format.\n    if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) {\n      await this.refreshAccessTokenAsync();\n    } // Return Downscoped access token in DownscopedAccessTokenResponse format.\n\n\n    return {\n      token: this.cachedDownscopedAccessToken.access_token,\n      expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n      res: this.cachedDownscopedAccessToken.res\n    };\n  }\n  /**\r\n   * The main authentication interface. It takes an optional url which when\r\n   * present is the endpoint being accessed, and returns a Promise which\r\n   * resolves with authorization header fields.\r\n   *\r\n   * The result has the form:\r\n   * { Authorization: 'Bearer <access_token_value>' }\r\n   */\n\n\n  async getRequestHeaders() {\n    const accessTokenResponse = await this.getAccessToken();\n    const headers = {\n      Authorization: `Bearer ${accessTokenResponse.token}`\n    };\n    return this.addSharedMetadataHeaders(headers);\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\r\n   * Authenticates the provided HTTP request, processes it and resolves with the\r\n   * returned response.\r\n   * @param opts The HTTP request options.\r\n   * @param retry Whether the current attempt is a retry after a failed attempt.\r\n   * @return A promise that resolves with the successful response.\r\n   */\n\n\n  async requestAsync(opts, retry = false) {\n    let response;\n\n    try {\n      const requestHeaders = await this.getRequestHeaders();\n      opts.headers = opts.headers || {};\n\n      if (requestHeaders && requestHeaders['x-goog-user-project']) {\n        opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n      }\n\n      if (requestHeaders && requestHeaders.Authorization) {\n        opts.headers.Authorization = requestHeaders.Authorization;\n      }\n\n      response = await this.transporter.request(opts);\n    } catch (e) {\n      const res = e.response;\n\n      if (res) {\n        const statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - forceRefreshOnFailure is true\n\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n\n        if (!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n          await this.refreshAccessTokenAsync();\n          return await this.requestAsync(opts, true);\n        }\n      }\n\n      throw e;\n    }\n\n    return response;\n  }\n  /**\r\n   * Forces token refresh, even if unexpired tokens are currently cached.\r\n   * GCP access tokens are retrieved from authclient object/source credential.\r\n   * Then GCP access tokens are exchanged for downscoped access tokens via the\r\n   * token exchange endpoint.\r\n   * @return A promise that resolves with the fresh downscoped access token.\r\n   */\n\n\n  async refreshAccessTokenAsync() {\n    var _a; // Retrieve GCP access token from source credential.\n\n\n    const subjectToken = (await this.authClient.getAccessToken()).token; // Construct the STS credentials options.\n\n    const stsCredentialsOptions = {\n      grantType: STS_GRANT_TYPE,\n      requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n      subjectToken: subjectToken,\n      subjectTokenType: STS_SUBJECT_TOKEN_TYPE\n    }; // Exchange the source AuthClient access token for a Downscoped access\n    // token.\n\n    const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n    /**\r\n     * The STS endpoint will only return the expiration time for the downscoped\r\n     * access token if the original access token represents a service account.\r\n     * The downscoped token's expiration time will always match the source\r\n     * credential expiration. When no expires_in is returned, we can copy the\r\n     * source credential's expiration time.\r\n     */\n\n    const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n    const expiryDate = stsResponse.expires_in ? new Date().getTime() + stsResponse.expires_in * 1000 : sourceCredExpireDate; // Save response in cached access token.\n\n    this.cachedDownscopedAccessToken = {\n      access_token: stsResponse.access_token,\n      expiry_date: expiryDate,\n      res: stsResponse.res\n    }; // Save credentials.\n\n    this.credentials = {};\n    Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n    delete this.credentials.res; // Trigger tokens event to notify external listeners.\n\n    this.emit('tokens', {\n      refresh_token: null,\n      expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n      access_token: this.cachedDownscopedAccessToken.access_token,\n      token_type: 'Bearer',\n      id_token: null\n    }); // Return the cached access token.\n\n    return this.cachedDownscopedAccessToken;\n  }\n  /**\r\n   * Returns whether the provided credentials are expired or not.\r\n   * If there is no expiry time, assumes the token is not expired or expiring.\r\n   * @param downscopedAccessToken The credentials to check for expiration.\r\n   * @return Whether the credentials are expired or not.\r\n   */\n\n\n  isExpired(downscopedAccessToken) {\n    const now = new Date().getTime();\n    return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n\n}\n\nexports.DownscopedClient = DownscopedClient;","map":{"version":3,"sources":["C:/Users/Enrique Niebles/Documents/MisiÃ³n TIC 2021/Ciclo 3 - Desarrollo Software/Grupo-4/grupo4/react/node_modules/google-auth-library/build/src/auth/downscopedclient.js"],"names":["Object","defineProperty","exports","value","DownscopedClient","EXPIRATION_TIME_OFFSET","MAX_ACCESS_BOUNDARY_RULES_COUNT","stream","require","authclient_1","sts","STS_GRANT_TYPE","STS_REQUEST_TOKEN_TYPE","STS_SUBJECT_TOKEN_TYPE","STS_ACCESS_TOKEN_URL","AuthClient","constructor","authClient","credentialAccessBoundary","additionalOptions","quotaProjectId","accessBoundary","accessBoundaryRules","length","Error","rule","availablePermissions","stsCredential","StsCredentials","cachedDownscopedAccessToken","eagerRefreshThresholdMillis","forceRefreshOnFailure","setCredentials","credentials","expiry_date","getAccessToken","isExpired","refreshAccessTokenAsync","token","access_token","expirationTime","res","getRequestHeaders","accessTokenResponse","headers","Authorization","addSharedMetadataHeaders","request","opts","callback","requestAsync","then","r","e","response","retry","requestHeaders","transporter","statusCode","status","isReadableStream","config","data","Readable","isAuthErr","_a","subjectToken","stsCredentialsOptions","grantType","requestedTokenType","subjectTokenType","stsResponse","exchangeToken","undefined","sourceCredExpireDate","expiryDate","expires_in","Date","getTime","assign","emit","refresh_token","token_type","id_token","downscopedAccessToken","now"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Copyright 2021 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\r\nconst stream = require(\"stream\");\r\nconst authclient_1 = require(\"./authclient\");\r\nconst sts = require(\"./stscredentials\");\r\n/**\r\n * The required token exchange grant_type: rfc8693#section-2.1\r\n */\r\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\r\n/**\r\n * The requested token exchange requested_token_type: rfc8693#section-2.1\r\n */\r\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\r\n/**\r\n * The requested token exchange subject_token_type: rfc8693#section-2.1\r\n */\r\nconst STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\r\n/** The STS access token exchange end point. */\r\nconst STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1/token';\r\n/**\r\n * The maximum number of access boundary rules a Credential Access Boundary\r\n * can contain.\r\n */\r\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\r\n/**\r\n * Offset to take into account network delays and server clock skews.\r\n */\r\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\r\n/**\r\n * Defines a set of Google credentials that are downscoped from an existing set\r\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\r\n * Access Management (IAM) permissions that a short-lived credential can use.\r\n * The common pattern of usage is to have a token broker with elevated access\r\n * generate these downscoped credentials from higher access source credentials\r\n * and pass the downscoped short-lived access tokens to a token consumer via\r\n * some secure authenticated channel for limited access to Google Cloud Storage\r\n * resources.\r\n */\r\nclass DownscopedClient extends authclient_1.AuthClient {\r\n    /**\r\n     * Instantiates a downscoped client object using the provided source\r\n     * AuthClient and credential access boundary rules.\r\n     * To downscope permissions of a source AuthClient, a Credential Access\r\n     * Boundary that specifies which resources the new credential can access, as\r\n     * well as an upper bound on the permissions that are available on each\r\n     * resource, has to be defined. A downscoped client can then be instantiated\r\n     * using the source AuthClient and the Credential Access Boundary.\r\n     * @param authClient The source AuthClient to be downscoped based on the\r\n     *   provided Credential Access Boundary rules.\r\n     * @param credentialAccessBoundary The Credential Access Boundary which\r\n     *   contains a list of access boundary rules. Each rule contains information\r\n     *   on the resource that the rule applies to, the upper bound of the\r\n     *   permissions that are available on that resource and an optional\r\n     *   condition to further restrict permissions.\r\n     * @param additionalOptions Optional additional behavior customization\r\n     *   options. These currently customize expiration threshold time and\r\n     *   whether to retry on 401/403 API request errors.\r\n     * @param quotaProjectId Optional quota project id for setting up in the\r\n     *   x-goog-user-project header.\r\n     */\r\n    constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {\r\n        super();\r\n        this.authClient = authClient;\r\n        this.credentialAccessBoundary = credentialAccessBoundary;\r\n        // Check 1-10 Access Boundary Rules are defined within Credential Access\r\n        // Boundary.\r\n        if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\r\n            throw new Error('At least one access boundary rule needs to be defined.');\r\n        }\r\n        else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length >\r\n            exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\r\n            throw new Error('The provided access boundary has more than ' +\r\n                `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\r\n        }\r\n        // Check at least one permission should be defined in each Access Boundary\r\n        // Rule.\r\n        for (const rule of credentialAccessBoundary.accessBoundary\r\n            .accessBoundaryRules) {\r\n            if (rule.availablePermissions.length === 0) {\r\n                throw new Error('At least one permission should be defined in access boundary rules.');\r\n            }\r\n        }\r\n        this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\r\n        this.cachedDownscopedAccessToken = null;\r\n        // As threshold could be zero,\r\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\r\n        // zero value.\r\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\r\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\r\n        }\r\n        else {\r\n            this.eagerRefreshThresholdMillis = additionalOptions\r\n                .eagerRefreshThresholdMillis;\r\n        }\r\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\r\n        this.quotaProjectId = quotaProjectId;\r\n    }\r\n    /**\r\n     * Provides a mechanism to inject Downscoped access tokens directly.\r\n     * The expiry_date field is required to facilitate determination of the token\r\n     * expiration which would make it easier for the token consumer to handle.\r\n     * @param credentials The Credentials object to set on the current client.\r\n     */\r\n    setCredentials(credentials) {\r\n        if (!credentials.expiry_date) {\r\n            throw new Error('The access token expiry_date field is missing in the provided ' +\r\n                'credentials.');\r\n        }\r\n        super.setCredentials(credentials);\r\n        this.cachedDownscopedAccessToken = credentials;\r\n    }\r\n    async getAccessToken() {\r\n        // If the cached access token is unavailable or expired, force refresh.\r\n        // The Downscoped access token will be returned in\r\n        // DownscopedAccessTokenResponse format.\r\n        if (!this.cachedDownscopedAccessToken ||\r\n            this.isExpired(this.cachedDownscopedAccessToken)) {\r\n            await this.refreshAccessTokenAsync();\r\n        }\r\n        // Return Downscoped access token in DownscopedAccessTokenResponse format.\r\n        return {\r\n            token: this.cachedDownscopedAccessToken.access_token,\r\n            expirationTime: this.cachedDownscopedAccessToken.expiry_date,\r\n            res: this.cachedDownscopedAccessToken.res,\r\n        };\r\n    }\r\n    /**\r\n     * The main authentication interface. It takes an optional url which when\r\n     * present is the endpoint being accessed, and returns a Promise which\r\n     * resolves with authorization header fields.\r\n     *\r\n     * The result has the form:\r\n     * { Authorization: 'Bearer <access_token_value>' }\r\n     */\r\n    async getRequestHeaders() {\r\n        const accessTokenResponse = await this.getAccessToken();\r\n        const headers = {\r\n            Authorization: `Bearer ${accessTokenResponse.token}`,\r\n        };\r\n        return this.addSharedMetadataHeaders(headers);\r\n    }\r\n    request(opts, callback) {\r\n        if (callback) {\r\n            this.requestAsync(opts).then(r => callback(null, r), e => {\r\n                return callback(e, e.response);\r\n            });\r\n        }\r\n        else {\r\n            return this.requestAsync(opts);\r\n        }\r\n    }\r\n    /**\r\n     * Authenticates the provided HTTP request, processes it and resolves with the\r\n     * returned response.\r\n     * @param opts The HTTP request options.\r\n     * @param retry Whether the current attempt is a retry after a failed attempt.\r\n     * @return A promise that resolves with the successful response.\r\n     */\r\n    async requestAsync(opts, retry = false) {\r\n        let response;\r\n        try {\r\n            const requestHeaders = await this.getRequestHeaders();\r\n            opts.headers = opts.headers || {};\r\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\r\n                opts.headers['x-goog-user-project'] =\r\n                    requestHeaders['x-goog-user-project'];\r\n            }\r\n            if (requestHeaders && requestHeaders.Authorization) {\r\n                opts.headers.Authorization = requestHeaders.Authorization;\r\n            }\r\n            response = await this.transporter.request(opts);\r\n        }\r\n        catch (e) {\r\n            const res = e.response;\r\n            if (res) {\r\n                const statusCode = res.status;\r\n                // Retry the request for metadata if the following criteria are true:\r\n                // - We haven't already retried.  It only makes sense to retry once.\r\n                // - The response was a 401 or a 403\r\n                // - The request didn't send a readableStream\r\n                // - forceRefreshOnFailure is true\r\n                const isReadableStream = res.config.data instanceof stream.Readable;\r\n                const isAuthErr = statusCode === 401 || statusCode === 403;\r\n                if (!retry &&\r\n                    isAuthErr &&\r\n                    !isReadableStream &&\r\n                    this.forceRefreshOnFailure) {\r\n                    await this.refreshAccessTokenAsync();\r\n                    return await this.requestAsync(opts, true);\r\n                }\r\n            }\r\n            throw e;\r\n        }\r\n        return response;\r\n    }\r\n    /**\r\n     * Forces token refresh, even if unexpired tokens are currently cached.\r\n     * GCP access tokens are retrieved from authclient object/source credential.\r\n     * Then GCP access tokens are exchanged for downscoped access tokens via the\r\n     * token exchange endpoint.\r\n     * @return A promise that resolves with the fresh downscoped access token.\r\n     */\r\n    async refreshAccessTokenAsync() {\r\n        var _a;\r\n        // Retrieve GCP access token from source credential.\r\n        const subjectToken = (await this.authClient.getAccessToken()).token;\r\n        // Construct the STS credentials options.\r\n        const stsCredentialsOptions = {\r\n            grantType: STS_GRANT_TYPE,\r\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\r\n            subjectToken: subjectToken,\r\n            subjectTokenType: STS_SUBJECT_TOKEN_TYPE,\r\n        };\r\n        // Exchange the source AuthClient access token for a Downscoped access\r\n        // token.\r\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\r\n        /**\r\n         * The STS endpoint will only return the expiration time for the downscoped\r\n         * access token if the original access token represents a service account.\r\n         * The downscoped token's expiration time will always match the source\r\n         * credential expiration. When no expires_in is returned, we can copy the\r\n         * source credential's expiration time.\r\n         */\r\n        const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\r\n        const expiryDate = stsResponse.expires_in\r\n            ? new Date().getTime() + stsResponse.expires_in * 1000\r\n            : sourceCredExpireDate;\r\n        // Save response in cached access token.\r\n        this.cachedDownscopedAccessToken = {\r\n            access_token: stsResponse.access_token,\r\n            expiry_date: expiryDate,\r\n            res: stsResponse.res,\r\n        };\r\n        // Save credentials.\r\n        this.credentials = {};\r\n        Object.assign(this.credentials, this.cachedDownscopedAccessToken);\r\n        delete this.credentials.res;\r\n        // Trigger tokens event to notify external listeners.\r\n        this.emit('tokens', {\r\n            refresh_token: null,\r\n            expiry_date: this.cachedDownscopedAccessToken.expiry_date,\r\n            access_token: this.cachedDownscopedAccessToken.access_token,\r\n            token_type: 'Bearer',\r\n            id_token: null,\r\n        });\r\n        // Return the cached access token.\r\n        return this.cachedDownscopedAccessToken;\r\n    }\r\n    /**\r\n     * Returns whether the provided credentials are expired or not.\r\n     * If there is no expiry time, assumes the token is not expired or expiring.\r\n     * @param downscopedAccessToken The credentials to check for expiration.\r\n     * @return Whether the credentials are expired or not.\r\n     */\r\n    isExpired(downscopedAccessToken) {\r\n        const now = new Date().getTime();\r\n        return downscopedAccessToken.expiry_date\r\n            ? now >=\r\n                downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis\r\n            : false;\r\n    }\r\n}\r\nexports.DownscopedClient = DownscopedClient;\r\n//# sourceMappingURL=downscopedclient.js.map"]},"metadata":{},"sourceType":"script"}